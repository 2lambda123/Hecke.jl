
export meataxe, charpoly, composition_factors, composition_series, submodules, maximal_submodules, minimal_submodules


####################################################################
#
#  Tools for MeatAxe
#
#####################################################################


#
# Given a matrix $M$ in echelon form and a vector, it returns
# the vector reduced with respect to $M$
#
function cleanvect(M::MatElem, v::MatElem)
  
  @assert rows(v)==1
  w=deepcopy(v)
  if iszero(v)
    return w  
  end
  for i=1:rows(M)
    ind=1
    while M[i,ind]==0
      ind+=1
    end
    if iszero(w[1,ind])
      continue
    end
    mult=w[1,ind]//M[i,ind]
    w[1,ind]=parent(M[1,1])(0)
    for k=ind+1:cols(M)
      w[1,k]-= mult*M[i,k]
    end      
  end
  return w

end

function cleanmat(M::MatElem,N::MatElem)
  
  S=MatrixSpace(parent(M[1,1]), rows(N),cols(N))()
  for i=1:nrows(N)
    v=MatrixSpace(parent(M[1,1]), 1 ,cols(N))()
    for j=1:cols(N)
      v[j]=N[i,j]
    end
    w=cleanvec(M,v)
    for j=1:cols(N)
      S[i,j]=w[j]
    end
  end
  return S
  
end


function submatrix(M::MatElem, x::UnitRange{Int}, y::UnitRange{Int})
  
  numrows=x.stop-x.start+1
  numcols=y.stop-y.start+1
  A=MatrixSpace(parent(M[1,1]), numrows, numcols)()
  for i=1:numrows
    for j=1:numcols
      A[i,j]=M[x.start+i-1, y.start+j-1]
    end
  end
  return A
  
end


#
#  Given a matrix C containing the coordinates of vectors v_1,dots, v_k 
#  in echelon form, the function computes a basis for the submodule they generate
# 

function closure(C::MatElem, G)

  rref!(C)
  i=1
  while i != rows(C)+1
    for j=1:length(G)
      res= cleanvect(C,submatrix(C, i:i, 1:cols(C))*G[j])
      if !iszero(res)
        C=vcat(C,res)    
      end
    end  
    i+=1
  end
  rref!(C)
  return C

end

#
#  Given a matrix C containing the coordinates of vectors v_1,dots, v_k,
#  the function computes a basis for the submodule they generate
# 

function spinning(C::MatElem,G)

  preimage=[i for i=1:rows(C)]
  gens=[0 for i=1:rows(C)]
  X=rref(C)[2]
  B=deepcopy(C)
  i=1
  while i != rows(B)+1
    for j=1:length(G)
      el=submatrix(B, i:i, 1:cols(B))*G[j]
      res= cleanvect(X,el)
      if !iszero(res)
        X=vcat(X,res)
        rref!(X)
        B=vcat(B,el)
        push!(gens,j)
        push!(preimage,i)
      end
    end  
    i+=1
  end
  return B,gens, preimage
  

end


#
#  Function to obtain the action of G on the quotient and on the submodule
#


function clean_and_quotient(M::MatElem,N::MatElem,pivotindex::Set{Int})
  
  
  coeff=MatrixSpace(parent(M[1,1]),rows(N),rows(M))()
  for i=1:rows(N)
    for j=1:rows(M)
      ind=1
      while iszero(M[j,ind])
        ind+=1
      end
      coeff[i,j]=N[i,ind]//M[j,ind]  
      for s=1:cols(N)
        N[i,s]-=coeff[i,j]*M[j,s]
      end
    end
  end 
  vec= MatrixSpace(parent(M[1,1]),rows(N),cols(M)-length(pivotindex))()
  for i=1:rows(N)  
    pos=0
    for s=1:cols(M)
      if !(s in pivotindex)
        pos+=1
        vec[i,pos]=N[i,s]
      end 
    end
  end
  return coeff, vec
end

#
#  Restriction of the action to the submodule generated by C and the quotient
#

function _split(C::MatElem,G)
# I am assuming that C is a Fp[G]-submodule

  equot=MatElem[]
  esub=MatElem[]
  pivotindex=Set{Int}()
  for i=1:rows(C)
    ind=1
    while iszero(C[i,ind])
      ind+=1
    end
    push!(pivotindex,ind)   
  end
  for a=1:length(G)
    subm,vec=clean_and_quotient(C, C*G[a],pivotindex)
    push!(esub,subm)
    s=MatrixSpace(parent(C[1,1]),cols(G[1])-length(pivotindex),cols(G[1])-length(pivotindex))()
    pos=0
    for i=1:rows(G[1])
      if !(i in pivotindex)
        m,vec=clean_and_quotient(C,submatrix(G[a],i:i,1:rows(G[1])),pivotindex)
        for j=1:cols(vec)
          s[i-pos,j]=vec[1,j]
        end
      else 
        pos+=1
      end
    end
    push!(equot,s)
  end
  return FqGModule(esub),FqGModule(equot),pivotindex

end

#
#  Restriction of the action to the submodule generated by C
#

function actsub(C::MatElem,G)

  esub=MatElem[]
  pivotindex=Set{Int}()
  for i=1:rows(C)
    ind=1
    while iszero(C[i,ind])
      ind+=1
    end
    push!(pivotindex,ind)   
  end
  for a=1:length(G)
    subm,vec=clean_and_quotient(C, C*G[a],pivotindex)
    push!(esub,subm)
  end
  return FqGModule(esub)
end

#
#  Restriction of the action to the quotient by the submodule generated by C
#

function actquo(C::MatElem,G)

  equot=MatElem[]
  pivotindex=Set{Int}()
  for i=1:rows(C)
    ind=1
    while iszero(C[i,ind])
      ind+=1
    end
    push!(pivotindex,ind)   
  end
  for a=1:length(G)
    s=MatrixSpace(parent(C[1,1]),cols(G[1])-length(pivotindex),cols(G[1])-length(pivotindex))()
    pos=0
    for i=1:rows(G[1])
      if !(i in pivotindex)
        m,vec=clean_and_quotient(C,submatrix(G[a],i:i,1:rows(G[1])),pivotindex)
        for j=1:cols(vec)
          s[i-pos,j]=vec[1,j]
        end
      else 
        pos+=1
      end
    end
    push!(equot,s)
  end
  return FqGModule(equot), pivotindex
  
end


#
#  Function that determine if two G-modules are isomorphic, provided that the first is irreducible
#

function isisomorphic(M::FqGModule,N::FqGModule)
  
  @assert M.isirreducible==true
  @assert M.K==N.K
  
  if M.dim!=N.dim
    return false
  end
  n=M.dim
    
  K=M.K
 
  G=M.G
  H=N.G
  if length(G)!=length(H)
    return false
  end
  
  if isdefined(M, :peakword_poly)
    lincomb=M.peakword_elem
    f=M.peakword_poly
  else
    e,lincomb,f= _spl_field(M)
  end
  
  A=MatrixSpace(K,n,n)()
  B=MatrixSpace(K,n,n)()
  
  for i=1:length(G)
    A+=lincomb[i]*G[i]
    B+=lincomb[i]*H[i]
  end
  
  M=f(A)
  a,kerA=nullspace(transpose(M))
  kerA=transpose(kerA)
  
  N=f(B)
  b,kerB=nullspace(transpose(M))
  kerB=transpose(kerB)

  if a!=b
    return false
  end
  
  M, gensA, preimageA = spinning(submatrix(kerA, 1:1, 1:n), G)
  N, gensB, preimageB = spinning(submatrix(kerB, 1:1, 1:n), H)
  
  
  for i=1:length(G)
    if M*G[1]*inv(M) != N*H[1]*inv(N)
      return false
    end
  end
  return true
end

function peakwords(L)

  K=L[1][1].K
  i=1
  while i<=length(L)
    a,lincomb,f=_spl_field(L[i][1])
    found=true
    for j=1:i-1
      A=MatrixSpace(K,L[j][1].dim,L[j][1].dim)()
      for k=1:length(L[1][1].G)
        A+=lincomb[k]*L[j][1].G[k]
      end
      A=f(A)
      if rank(A)!=L[j][1].dim
        found=false
        break
      end
    end
    if found==true
      i=i+1
    end
  end
  return L

end



function _spl_field(M::FqGModule)
  
  @assert M.isirreducible==true
  n=M.dim
  K=M.K
  G=M.G
  posfac=n
  lincomb=Int[]
  Kx,x=K["x"]
  f=Kx(1)
  A=MatrixSpace(K,n,n)()
  
  while true
    
    for i=1:length(G)
      push!(lincomb,rand(1:10))
      A+=lincomb[i]*G[i]
    end

    cp=charpoly(A)
    sq=factor_squarefree(cp)
    lf=factor(collect(keys(sq.fac))[1])
    for t in keys(lf.fac)
      f=t
      if divides(cp,f^2)[1]
        continue
      end
      S=t(A)
      a,kerA=nullspace(transpose(S))
      if a==1
        M.peakword_elem=lincomb
        M.peakword_poly=f
        return a, lincomb, f
      end
      kerA=transpose(kerA)
      posfac=gcd(posfac,a)
      if divisible(fmpz(posfac),a)
        v=submatrix(kerA, 1:1, 1:n)
        B=v
        T,gensA, preimageA =spinning(v,G)
        G1=[T*A*inv(T) for A in G]
        i=2
        E=[eye(T,a)]
        while rows(B)!= a
          w=submatrix(kerA, i:i, 1:n)
          z=cleanvect(B,w)
          if iszero(z)
            continue
          end
          N,gensB, preimageB=spinning(w,G)
          G2=[N*A*inv(N) for A in G]
          if G1 == G2
            b=kerA*N
            x=transpose(solve(transpose(kerA),transpose(b)))
            push!(E,x)
            B=vcat(B,z)
            B=closure(B,E)
          else 
            break
          end
          if rows(B)==a
            M.peakword_elem=lincomb
            M.peakword_poly=f
            return a, lincomb, f
          else
            i+=1
          end
        end
      end
    end        
    lincomb=Int[]
    A=MatrixSpace(K,n,n)()

  end
  
end



function _solve_unique(A::GenMat{fq_nmod}, B::GenMat{fq_nmod})
  X = MatrixSpace(base_ring(A), cols(B), rows(A))()

  #println("solving\n $A \n = $B * X")
  r, per, L, U = lufact(B) # P*M1 = L*U

  if oldNemo
    for i in 1:length(per.d)
      per.d[i] += 1
    end
  end

  @assert B == per*L*U
  Ap = inv(per)*A
  Y = parent(A)()

  #println("first solve\n $Ap = $L * Y")

  for i in 1:cols(Y)
    for j in 1:rows(Y)
      s = Ap[j, i]
      for k in 1:j-1
        s = s - Y[k, i]*L[j, k]
      end
      Y[j, i] = s
    end
  end

  @assert Ap == L*Y

  #println("solving \n $Y \n = $U * X")

  YY = submatrix(Y, 1:r, 1:cols(Y))
  UU = submatrix(U, 1:r, 1:r)
  X = inv(UU)*YY

  @assert Y == U * X

  @assert B*X == A
  return X
end


###############################################################
#
#  Characteristic Polynomial
#
#################################################################


function ordpoly(M::MatElem,S::MatElem,v::MatElem)

  K=parent(M[1,1])
  D=cleanvect(S,v)
  C=MatrixSpace(K, 1, cols(M)+1)()
  C[1,1]=K(1)
  if iszero(D)
    return C
  end
  ind=2
  vec=v
  while true
    vec=vec*M
    D=vcat(D, cleanvect(S,vec))
    E=MatrixSpace(K, 1, cols(M)+1)()
    E[1,ind]=K(1)
    C=vcat(C,E)
    for i=1:ind-1
      nonzero=1
      while iszero(D[i, nonzero])
      nonzero+=1
      end
      mult=D[ind,nonzero]//D[i,nonzero]
      for j=1:cols(M)+1
        C[ind,j]-=mult*C[i,j]
      end
      for j=1:cols(M)
        D[ind,j]-=mult*D[i,j]
      end
    end
    if iszero(submatrix(D, ind:ind, 1:cols(D)))
      break
    end
    ind+=1
  end
  return submatrix(C, ind:ind, 1:cols(D)+1), submatrix(D, 1:ind-1, 1:cols(D))
  
end

function charpoly_fact(M::MatElem)
  
  @assert cols(M)>0 && cols(M)==rows(M) 
  
  K=parent(M[1,1])
  polys=[]
  v=MatrixSpace(K, 1, cols(M))()
  v[1,1]=K(1)
  pol,B=ordpoly(M,MatrixSpace(K, 0, 0)(),v)
  push!(polys,pol)
  if pol[1,cols(B)+1]!=0
    return polys
  end
  v[1,1]=K(0)
  for i=2:cols(M)
    v[1,i]=K(1)
    red=cleanvect(B,v)
    if !iszero(red)
      x=ordpoly(M,B,red)
      push!(polys,x[1])
      B=vcat(B,x[2])
    end
    v[1,i]=K(0)
  end
  return polys
end


doc"""
***
    charpoly(M::MatElem) -> PolyElem

> Returns the characteristic polynomial of the square matrix M

"""

function charpoly(M::MatElem)
  
  @assert rows(M)>0 && rows(M)==cols(M)
  K=parent(M[1,1])
  Kx,x=K["x"]
  polys=charpoly_fact(M)
  f=Kx(1)
  for pol in polys
    coeff=[pol[1,i] for i=1:cols(pol)]
    f*=Kx(coeff)
  end
  return f
end


#################################################################
#
#  MeatAxe, Composition Factors and Composition Series
#
#################################################################



doc"""
***
    meataxe(M::FqGModule) -> Bool, MatElem

> Given module M, returns true if the module is irreducible (and the identity matrix) and false if the space is reducible, togheter with a basis of a submodule

"""

function meataxe(M::FqGModule)

  K=M.K
  Kx,x=K["x"]
  n=M.dim
  G=M.G
  if M.dim==1
    M.isirreducible=true
    return true, eye(G[1],n)
  end
  
  if length(G)==1
    A=G[1]
    poly=charpoly_fact(A)
    for fact in poly
      c=[fact[1,i] for i=1:cols(fact)]
      sq=factor_squarefree(Kx(c))
      lf=factor(collect(keys(sq.fac))[1])
      t=first(keys(lf.fac))
      if degree(t)==n
        M.isirreducible=true
        return true, eye(G[1],n)
      else 
        N=t(A)
        kern=transpose(nullspace(transpose(N))[2])
        B=closure(submatrix(kern,1:1, 1:n),G)
        return false, B
      end
    end
  end
  
  while true
  #
  # First, choose a random combination of the generators of G
  #
    A=MatrixSpace(K,n,n)()
    for i=1:length(G)
      A+=rand(1:10)*G[i]
    end
 
  #
  # Compute the characteristic polynomial and, for irreducible factor f, try the Norton test
  # 
    poly=charpoly_fact(A)
    for fact in poly
      c=[fact[1,i] for i=1:cols(fact)]
      sq=factor_squarefree(Kx(c))
      lf=factor(collect(keys(sq.fac))[1])
      for t in keys(lf.fac)
        N=t(A)
        a,kern=nullspace(transpose(N))
        kern=transpose(kern)
  
        #
        #  Norton test
        #   
        for j=1:rows(kern)  
          B=closure(submatrix(kern,j:j, 1:n),G)
          if rows(B)!=n
            M.isirreducible=false
            return false, B
          end
        end        
        kernt=nullspace(N)[2]
        
        for j=1:cols(kernt)
          Bt=closure(transpose(submatrix(kernt,1:n,j:j)),[transpose(x) for x in G])
          if rows(Bt)!=n
            subs=nullspace(Bt)[2]
            subst=transpose(subs)
            @assert rows(subst)==rows(closure(subst,G))
            M.isirreducible=false
            return false, subst
          end
        end
        if degree(t)==a
          #
          # f is a good factor, irreducibility!
          #
          M.isirreducible=true
          return true, eye(G[1],n)
        end
      end
    end
  end
end

doc"""
***
    composition_series(G::Array{MatElem,1}) -> Array{MatElem,1}

> Given a set of matrices $G$, returns a sequence of submodules such that the quotient of two consecutive submodules is irreducible

"""



function composition_series(M::FqGModule)

  if isdefined(M, :isirreducible) && M.isirreducible==true
    return [eye(M.G[1],M.dim)]
  end

  bool, C = meataxe(M)
  #
  #  If the module is irreducible, we return a basis of the space
  #
  if bool ==true
    return [eye(M.G[1],M.dim)]
  end
  #
  #  The module is reducible, so we call the algorithm on the quotient and on the subgroup
  #
  G=M.G
  K=M.K
  
  rref!(C)
  
  esub,equot,pivotindex=_split(C,G)
  sub_list = composition_series(esub)
  quot_list = composition_series(equot)
  #
  #  Now, we have to write the submodules of the quotient and of the submodule in terms of our basis
  #
  list=MatElem[]
  for a in sub_list
    m=MatrixSpace(K,rows(a), cols(C))()
    for i=1:rows(a)
      for s=1:cols(a)
        for j=1:cols(C)
          m[i,j]+=a[i,s]*C[s,j]
        end
      end
    end
    push!(list,m)
  end
  for a in quot_list
    s=MatrixSpace(K,rows(a), cols(C))()
    for i=1:rows(a)
      pos=0
      for j=1:cols(C)
        if j in pivotindex
          pos+=1
        else
          s[i,j]=a[i,j-pos]
        end
      end
    end
    push!(list,vcat(C,s))
  end
  return list
end

doc"""
***
    composition_factors(M::FqGModule)

> Given a $G$-module $M$, returns, up to isomorphism, the composition factors of $M$ with their multiplicity

"""



function composition_factors(M::FqGModule)
  
  if isdefined(M, :isirreducible) && M.isirreducible==true
    return [[M,1]]
  end 
 
  K=M.K
  
  bool, C = meataxe(M)
  #
  #  If the module is irreducible, we just return a basis of the space
  #
  if bool == true
    return [[M,1]]
  end
  G=M.G
  #
  #  The module is reducible, so we call the algorithm on the quotient and on the subgroup
  #
  
  rref!(C)
  
  esub,equot,pivotindex=_split(C,G)
  sub_list = composition_factors(esub)
  quot_list = composition_factors(equot)
  #
  #  Now, we check if the factors are isomorphic
  #
  list=vcat(sub_list,quot_list)
  i=1
  while i<=length(list)
    j=i+1
    while j<=length(list)
      if isisomorphic(list[i][1], list[j][1])
        list[i][2]+=list[j][2]
        deleteat!(list,j)
      else 
        j+=1
      end    
    end
    i+=1
  end

  return list

end



function _relations(M::FqGModule, N::FqGModule)

  G=M.G
  H=N.G
  K=M.K
  n=M.dim
  
  preimage=[i for i=1:M.dim]
  gens=[0 for i=1:M.dim]
  sys=MatrixSpace(K,0,N.dim)()

    

  B=MatrixSpace(K,1,M.dim)()
  B[1,1]=K(1)
  X=B

  i=1
  while i<=rows(B)
    w=submatrix(B, i:i, 1:n)
    for j=1:length(G)
      v=w*G[j]
      res=cleanvect(X,v)
      if !iszero(res)
        X=vcat(X,res)
        rref!(X)
        B=vcat(B,v)
        preimage[rows(B)]=i
        gens[rows(B)]=j
      else
        x=transpose(_solve_unique(transpose(v),transpose(B)))
        @assert cols(x)==rows(B)
        A=x[1,1]*eye(B,N.dim)
        A1=x[1,1]*eye(B,M.dim)
        for t=2:cols(x)
          C=H[gens[t]]
          C1=G[gens[t]]
          y=preimage[t]
          while y!=1
            C=C*H[gens[y]]
            C1=C1*G[gens[y]]
            y=preimage[y]
          end
          A+=x[1,t]*C
          A1+=x[1,t]*C1
        end
        if i==1
          A=A-H[j]
          A1=A1-G[j]
        else  
          C=H[j]*H[gens[i]]
          C1=G[j]*G[gens[i]]
          y=preimage[i]
          while y!=1
            C=C*H[gens[y]]
            C1=C1*G[gens[y]]
            y=preimage[y]
          end
          A=A-C
          A1=A1-C1
        end
        sys=vcat(sys,transpose(A))
      end
    end
    i=i+1
  end
  return sys
end

function _irrsubs(M::FqGModule, N::FqGModule)

  @assert M.isirreducible==true
  
  K=M.K
  rel=_relations(M,N)
  
  a,kern=nullspace(rel)
  kern=transpose(kern)
  if a==0
    return []
  end
  if a==1
    return [closure(kern, N.G)]
  end  
  candidate_comb=append!(_enum_el(K,[K(0)], a-1),_enum_el(K,[K(1)],a-1))
  list=[]
  for x in candidate_comb
    push!(list, sum([x[i]*submatrix(kern, i:i, 1:N.dim) for i=1:a]))
  end
  list[1]=closure(list[1], N.G)
  i=2
  w=MatrixSpace(K,0,0)()
  while i<length(list)
    for j=1:i-1
      w=cleanvect(list[j],list[i])
      if iszero(w)
        break
      end
    end  
    if iszero(w)
      deleteat!(list,i)
    else
      list[i]=closure(list[i],N.G)
      i=i+1
    end
  end
  return list

end

doc"""
***
    minimal_submodules(M::FqGModule)

> Given a $G$-module $M$, it returns all the minimal submodules of M

"""


function minimal_submodules(M::FqGModule, index::Int=M.dim)
  
  if M.isirreducible==true
    return []
  end
  
  K=M.K
  n=M.dim
  list=[]
  lf=composition_factors(M)
  if length(lf)==1
    return []
  end
  if index!=n
    i=1
    while i <= length(lf)
      if lf[i][1].dim!=index
        deleteat!(lf,i)
      else 
        i+=1
      end
    end
  end
  if isempty(lf)
    return list
  end
  Hecke.peakwords(lf)
  G=M.G
  for x in lf
    A=MatrixSpace(K,n,n)()
    for i=1:length(G)
      A+=x[1].peakword_elem[i]*G[i]
    end
    A=x[1].peakword_poly(A)
    a,kern=nullspace(transpose(A))
    if a==0
      continue
    end
    kern=transpose(kern)
    S=Hecke.closure(kern, G)
    if x[1].dim>rows(S)
      continue
    end
    N=Hecke.actsub(S,G)
    if N.dim == x[1].dim
      if isisomorphic(x[1],N)
        push!(list, S)
      end
      continue
    end 
    H=Hecke._irrsubs(x[1],N)
    for a in H
      m=MatrixSpace(K,rows(a), M.dim)()
      for t=1:rows(a)
        for s=1:cols(a)
          for j=1:M.dim
            m[t,j]+=a[t,s]*S[s,j]
          end
        end
      end
      push!(list,m)
    end
  end
  return list
end


function _enum_el(K,v,dim)
  
  if dim == 0
    return [v]
  else 
    list=[]
    push!(v,K(0))
    for x in K 
      v[length(v)]=x
      push!(list,deepcopy(v))
    end
    list1=[]
    for x in list
      append!(list1,_enum_el(K,x, dim-1))
    end
    return list1
  end
end

doc"""
***
    maximal_submodules(M::FqGModule)

> Given a $G$-module $M$, it returns all the maximal submodules of M

"""

function maximal_submodules(M::FqGModule, index::Int=M.dim)


  G=[transpose(A) for A in M.G]
  M_dual=FqGModule(G)
  minlist=minimal_submodules(M_dual, index)
  maxlist=[]
  for x in minlist
    push!(maxlist,transpose(nullspace(x)[2]))
  end
  return maxlist

end

doc"""
***
    submodules(M::FqGModule)

> Given a $G$-module $M$, it returns all the submodules of M

"""

function submodules(M::FqGModule)

  list=[]
  minlist=minimal_submodules(M)
  append!(list,minlist)
  for x in minlist
    N, pivotindex =actquo(x,M.G)
    ls=submodules(N)
    for a in ls
      s=MatrixSpace(K,rows(a), M.dim)()
      for i=1:rows(a)
        pos=0
        for j=1:M.dim
          if j in pivotindex
            pos+=1
          else
            s[i,j]=a[i,j-pos]
          end
        end
      end
      push!(list,vcat(x,s))
    end
    append!(list, ls)
  end
  return list
  
end

doc"""
***
    submodules(M::FqGModule, index::Int)

> Given a $G$-module $M$, it returns all the submodules of M of index q^index, where q is the order of the field

"""

function submodules(M::FqGModule, index::Int)
  
  list=[]
  if index> M.dim/2
    for i=1:index-1
      maxlist=maximal_submodules(M,i)
      for x in maxlist
        N=actsub(x,M.G)
        ls=submodules(N,index-i)
        for a in ls
          m=MatrixSpace(K,rows(a), M.dim)()
          for t=1:rows(a)
            for s=1:cols(a)
              for j=1:M.dim
                m[t,j]+=a[t,s]*x[s,j]
              end
            end
          end
          push!(list,m)
        end
      end
    end
    return append!(list,maximal_submodules(M,index))
  else 
    index=M.dim-index
    for i=1:index-1
      minlist=minimal_submodules(M,i)
      for x in minlist
        N, pivotindex= actquo(x,M.G)
        ls=submodules(N,index-i)
        for a in ls
          s=MatrixSpace(K,rows(a), M.dim)()
          for t=1:rows(a)
            pos=0
            for j=1:M.dim
              if j in pivotindex
                pos+=1
              else
                s[t,j]=a[t,j-pos]
              end
            end
          end
          push!(list,vcat(x,s))
        end
      end
      return append!(list,minimal_submodules(M,index))
    end
  end
    
end
    

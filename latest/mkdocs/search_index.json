{
    "docs": [
        {
            "location": "/", 
            "text": "Hecke\n\n\nBuilds\n\n\n\n\n\n\nAbout\n\n\nHecke is a software package for algebraic number theory maintained by Claus Fieker and Tommy Hofmann. It is written in \njulia\n and is based on the computer algebra package \nNemo\n.\n\n\n\n\nhttps://github.com/thofma/Hecke.jl\n (Source code)\n\n\nhttp://hecke.readthedocs.org/en/latest/\n (Online documentation)\n\n\n\n\nSo far, Hecke provides the following features:\n\n\n\n\nOrders (including element and ideal arithmetic) in number fields\n\n\nComputation of maximal orders\n\n\nVerified residue computations of Dedekind zeta functions\n\n\nFactor base creation and relations search in number fields\n\n\nLattice enumeration\n\n\nSparse linear algebra\n\n\n\n\n\n\nInstallation\n\n\nTo use Hecke, a julia version of 0.4 or higher is necessary (the latest stable julia version will do). Please see \nhttp://julialang.org/downloads\n for instructions on how to obtain julia for your system. Once a suitable julia version is installed, use the following steps at the julia prompt to install Hecke:\n\n\njulia\n \nPkg\n.\nclone\n(\nhttps://github.com/nemocas/Nemo.jl\n)\n\n\njulia\n \nPkg\n.\nclone\n(\nhttps://github.com/thofma/Hecke.jl\n)\n\n\njulia\n \nPkg\n.\nbuild\n(\nHecke\n)\n\n\n\n\n\n\n\n\nQuick start\n\n\nHere is a quick example of using Hecke:\n\n\njulia\n \nusing\n \nHecke\n\n\n...\n\n\n\nWelcome\n \nto\n \n\n  \n_\n    \n_\n           \n_\n        \n \n|\n \n|\n  \n|\n \n|\n         \n|\n \n|\n       \n \n|\n \n|\n__\n|\n \n|\n \n___\n  \n___\n|\n \n|\n \n_____\n \n \n|\n  \n__\n  \n|/\n \n_\n \\\n/\n \n__\n|\n \n|/\n \n/\n \n_\n \\\n \n|\n \n|\n  \n|\n \n|\n  \n__\n/\n \n(\n__\n|\n   \n  \n__\n/\n\n \n|\n_\n|\n  \n|\n_\n|\n\\\n___\n|\n\\\n___\n|\n_\n|\n\\\n_\n\\\n___\n|\n\n\n\nVersion\n \n0.1\n-\ndev\n \n...\n \n \n...\n \nwhich\n \ncomes\n \nwith\n \nabsolutely\n \nno\n \nwarrant\n \nwhatsoever\n\n\n(\nc\n)\n \n2015\n \nby\n \nClaus\n \nFieker\n \nand\n \nTommy\n \nHofmann\n\n\n\njulia\n \nQx\n,\n \nx\n \n=\n \nPolynomialRing\n(\nQQ\n,\n \nx\n);\n\n\njulia\n \nf\n \n=\n \nx\n^\n3\n \n+\n \n2\n;\n\n\njulia\n \nK\n,\n \na\n \n=\n \nNumberField\n(\nf\n,\n \na\n);\n\n\njulia\n \nO\n \n=\n \nMaximalOrder\n(\nK\n);\n\n\njulia\n \nO\n\n\nMaximal\n \norder\n \nof\n \nNumber\n \nfield\n \nover\n \nRational\n \nField\n \nwith\n \ndefining\n \npolynomial\n \nx\n^\n3\n \n+\n \n2\n \n\nwith\n \nbasis\n \n[\n1\n,\na\n,\na\n^\n2\n]\n\n\n\n\n\n\n\n\nDocumentation\n\n\nThe online documentation can be found here: [http://hecke.readthedocs.org/en/latest/]\n\n\nThe documentation of the single functions can also be accessed at the julia prompt. Here is an example:\n\n\nhelp?\n signature\nsearch: signature\n\n  ----------------------------------------------------------------------------\n\n  signature(O::NfMaximalOrder) -\n Tuple{Int, Int}\n\n  |  Returns the signature of the ambient number field of \\mathcal O.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#hecke", 
            "text": "Builds", 
            "title": "Hecke"
        }, 
        {
            "location": "/#about", 
            "text": "Hecke is a software package for algebraic number theory maintained by Claus Fieker and Tommy Hofmann. It is written in  julia  and is based on the computer algebra package  Nemo .   https://github.com/thofma/Hecke.jl  (Source code)  http://hecke.readthedocs.org/en/latest/  (Online documentation)   So far, Hecke provides the following features:   Orders (including element and ideal arithmetic) in number fields  Computation of maximal orders  Verified residue computations of Dedekind zeta functions  Factor base creation and relations search in number fields  Lattice enumeration  Sparse linear algebra", 
            "title": "About"
        }, 
        {
            "location": "/#installation", 
            "text": "To use Hecke, a julia version of 0.4 or higher is necessary (the latest stable julia version will do). Please see  http://julialang.org/downloads  for instructions on how to obtain julia for your system. Once a suitable julia version is installed, use the following steps at the julia prompt to install Hecke:  julia   Pkg . clone ( https://github.com/nemocas/Nemo.jl )  julia   Pkg . clone ( https://github.com/thofma/Hecke.jl )  julia   Pkg . build ( Hecke )", 
            "title": "Installation"
        }, 
        {
            "location": "/#quick-start", 
            "text": "Here is a quick example of using Hecke:  julia   using   Hecke  ...  Welcome   to  \n\n   _      _             _         \n  |   |    |   |           |   |        \n  |   | __ |   |   ___    ___ |   |   _____  \n  |    __    |/   _  \\ /   __ |   |/   /   _  \\\n  |   |    |   |    __ /   ( __ |        __ / \n  | _ |    | _ | \\ ___ | \\ ___ | _ | \\ _ \\ ___ |  Version   0.1 - dev   ...  \n  ...   which   comes   with   absolutely   no   warrant   whatsoever  ( c )   2015   by   Claus   Fieker   and   Tommy   Hofmann  julia   Qx ,   x   =   PolynomialRing ( QQ ,   x );  julia   f   =   x ^ 3   +   2 ;  julia   K ,   a   =   NumberField ( f ,   a );  julia   O   =   MaximalOrder ( K );  julia   O  Maximal   order   of   Number   field   over   Rational   Field   with   defining   polynomial   x ^ 3   +   2   with   basis   [ 1 , a , a ^ 2 ]", 
            "title": "Quick start"
        }, 
        {
            "location": "/#documentation", 
            "text": "The online documentation can be found here: [http://hecke.readthedocs.org/en/latest/]  The documentation of the single functions can also be accessed at the julia prompt. Here is an example:  help?  signature\nsearch: signature\n\n  ----------------------------------------------------------------------------\n\n  signature(O::NfMaximalOrder) -  Tuple{Int, Int}\n\n  |  Returns the signature of the ambient number field of \\mathcal O.", 
            "title": "Documentation"
        }, 
        {
            "location": "/numberfields/introduction/", 
            "text": "Introduction", 
            "title": "Introduction"
        }, 
        {
            "location": "/numberfields/introduction/#introduction", 
            "text": "", 
            "title": "Introduction"
        }, 
        {
            "location": "/numberfields/orders/", 
            "text": "Creation\n\n\nOrder(B::Array{nf_elem, 1}, check::Bool = true) -\n NfOrd\n\n\n\n\n\n\n\nReturns the order with \n\\Z\n-basis \nB\n. If \ncheck\n is set, it is checked whether \nB\n defines an order.\n\n\n\n\nOrder(K::AnticNumberField, A::FakeFmpqMat, check::Bool = true) -\n NfOrd\n\n\n\n\n\n\n\nReturns the order which has basis matrix \nA\n with respect to the power basis of \nK\n. If \ncheck\n is set, it is checked whether \nA\n defines an order.\n\n\n\n\nEquationOrder(K::AnticNumberField) -\n NfOrd\n\n\n\n\n\n\n\nReturns the equation of the number field \nK\n.\n\n\n\n\n\n\nExample\n\n\njulia\n \nQx\n,\n \nx\n \n=\n \nPolynomialRing\n(\nQQ\n,\n \nx\n);\n\n\n\njulia\n \nK\n,\n \na\n \n=\n \nNumberField\n(\nx\n^\n2\n \n-\n \n2\n,\n \na\n);\n\n\n\njulia\n \nO\n \n=\n \nEquationOrder\n(\nK\n)\n\n\nOrder\n \nof\n \nNumber\n \nfield\n \nover\n \nRational\n \nField\n \nwith\n \ndefining\n \npolynomial\n \nx\n^\n2\n \n-\n \n2\n\n\nwith\n \nZ\n-\nbasis\n \n[\n1\n,\na\n]\n\n\n\n\n\n\n\n\nNote\n\n\nInternally there is a difference between arbitary orders and maximal orders.     An order will be treated as a maximal order, that is, as the ring of integers,     if it was computed in the following way.\n\n\n\n\nmaximal_order(K::AnticNumberField) -\n NfMaxOrd\nring_of_integers(K::AnticNumberField) -\n NfMaxOrd\n\n\n\n\n\n\n\nReturns the maximal order of \nK\n.\n\n\n\n\nmaximal_order(K::AnticNumberField, primes::Array{fmpz, 1}) -\n NfMaxOrd\nmaximal_order(K::AnticNumberField, primes::Array{Integer, 1}) -\n NfMaxOrd\nring_of_integers(K::AnticNumberField, primes::Array{fmpz, 1}) -\n NfMaxOrd\nring_of_integers(K::AnticNumberField, primes::Array{Integer, 1}) -\n NfMaxOrd\n\n\n\n\n\n\n\nAssuming that \nprimes\n contains all the prime numbers at which the equation order \n\\mathbf{Z}[\\alpha]\n of \nK = \\mathbf{Q}(\\alpha)\n is not maximal (e.g. \nprimes\n may contain all prime divisors of the discriminant of \n\\mathbf Z[\\alpha]\n), this function returns the maximal order of \nK\n.\n\n\n\n\nmake_maximal(O::NfOrd) -\n NfMaxOrd\n\n\n\n\n\n\n\nAssuming that \n\\mathcal O\n is an order, this function returns the same order as a maximal order.\n\n\n\n\njulia\n \nQx\n,\n \nx\n \n=\n \nPolynomialRing\n(\nQQ\n,\n \nx\n);\n\n\n\njulia\n \nK\n,\n \na\n \n=\n \nNumberField\n(\nx\n^\n2\n \n-\n \n2\n,\n \na\n);\n\n\n\njulia\n \nR\n \n=\n \nEquationOrder\n(\nK\n)\n\n\nOrder\n \nof\n \nNumber\n \nfield\n \nover\n \nRational\n \nField\n \nwith\n \ndefining\n \npolynomial\n \nx\n^\n2\n \n-\n \n2\n\n\nwith\n \nZ\n-\nbasis\n \n[\n1\n,\na\n]\n\n\n\njulia\n \nS\n \n=\n \nmake_maximal\n(\nR\n)\n\n\nMaximal\n \norder\n \nof\n \nNumber\n \nfield\n \nover\n \nRational\n \nField\n \nwith\n \ndefining\n \npolynomial\n \nx\n^\n2\n \n-\n \n2\n\n\nwith\n \nbasis\n \n[\n1\n,\na\n]\n\n\n\njulia\n \nT\n \n=\n \nmaximal_order\n(\nK\n)\n\n\nMaximal\n \norder\n \nof\n \nNumber\n \nfield\n \nover\n \nRational\n \nField\n \nwith\n \ndefining\n \npolynomial\n \nx\n^\n2\n \n-\n \n2\n\n\nwith\n \nbasis\n \n[\n1\n,\na\n]\n\n\n\njulia\n \nbasis_mat\n(\nS\n)\n \n==\n \nbasis_mat\n(\nT\n)\n\n\ntrue\n\n\n\n\n\n\n\n\nBasic properties\n\n\nsignature(O::NfOrd) -\n Tuple{Int, Int}\n\n\n\n\n\n\n\nReturns the signature of the ambient number field of \n\\mathcal O\n.\n\n\n\n\ndegree(O::NfOrd) -\n Int\n\n\n\n\n\n\n\nReturns the degree of \n\\mathcal O\n.\n\n\n\n\nnorm_change_const(O::NfOrd) -\n (Float64, Float64)\n\n\n\n\n\n\n\nReturns \n(c_1, c_2) \\in \\mathbf R_{>0}^2\n such that for all \nx = \\sum_{i=1}^d x_i \\omega_i \\in \\mathcal O\n we have \nT_2(x) \\leq c_1 \\cdot \\sum_i^d x_i^2\n and \n\\sum_i^d x_i^2 \\leq c_2 \\cdot T_2(x)\n, where \n(\\omega_i)_i\n is the \n\\mathbf Z\n-basis of \n\\mathcal O\n.\n\n\n\n\n\n\nElements\n\n\n\n\nIdeals", 
            "title": "Orders"
        }, 
        {
            "location": "/numberfields/orders/#creation", 
            "text": "Order(B::Array{nf_elem, 1}, check::Bool = true) -  NfOrd   Returns the order with  \\Z -basis  B . If  check  is set, it is checked whether  B  defines an order.   Order(K::AnticNumberField, A::FakeFmpqMat, check::Bool = true) -  NfOrd   Returns the order which has basis matrix  A  with respect to the power basis of  K . If  check  is set, it is checked whether  A  defines an order.   EquationOrder(K::AnticNumberField) -  NfOrd   Returns the equation of the number field  K .", 
            "title": "Creation"
        }, 
        {
            "location": "/numberfields/orders/#example", 
            "text": "julia   Qx ,   x   =   PolynomialRing ( QQ ,   x );  julia   K ,   a   =   NumberField ( x ^ 2   -   2 ,   a );  julia   O   =   EquationOrder ( K )  Order   of   Number   field   over   Rational   Field   with   defining   polynomial   x ^ 2   -   2  with   Z - basis   [ 1 , a ]    Note  Internally there is a difference between arbitary orders and maximal orders.     An order will be treated as a maximal order, that is, as the ring of integers,     if it was computed in the following way.   maximal_order(K::AnticNumberField) -  NfMaxOrd\nring_of_integers(K::AnticNumberField) -  NfMaxOrd   Returns the maximal order of  K .   maximal_order(K::AnticNumberField, primes::Array{fmpz, 1}) -  NfMaxOrd\nmaximal_order(K::AnticNumberField, primes::Array{Integer, 1}) -  NfMaxOrd\nring_of_integers(K::AnticNumberField, primes::Array{fmpz, 1}) -  NfMaxOrd\nring_of_integers(K::AnticNumberField, primes::Array{Integer, 1}) -  NfMaxOrd   Assuming that  primes  contains all the prime numbers at which the equation order  \\mathbf{Z}[\\alpha]  of  K = \\mathbf{Q}(\\alpha)  is not maximal (e.g.  primes  may contain all prime divisors of the discriminant of  \\mathbf Z[\\alpha] ), this function returns the maximal order of  K .   make_maximal(O::NfOrd) -  NfMaxOrd   Assuming that  \\mathcal O  is an order, this function returns the same order as a maximal order.   julia   Qx ,   x   =   PolynomialRing ( QQ ,   x );  julia   K ,   a   =   NumberField ( x ^ 2   -   2 ,   a );  julia   R   =   EquationOrder ( K )  Order   of   Number   field   over   Rational   Field   with   defining   polynomial   x ^ 2   -   2  with   Z - basis   [ 1 , a ]  julia   S   =   make_maximal ( R )  Maximal   order   of   Number   field   over   Rational   Field   with   defining   polynomial   x ^ 2   -   2  with   basis   [ 1 , a ]  julia   T   =   maximal_order ( K )  Maximal   order   of   Number   field   over   Rational   Field   with   defining   polynomial   x ^ 2   -   2  with   basis   [ 1 , a ]  julia   basis_mat ( S )   ==   basis_mat ( T )  true", 
            "title": "Example"
        }, 
        {
            "location": "/numberfields/orders/#basic-properties", 
            "text": "signature(O::NfOrd) -  Tuple{Int, Int}   Returns the signature of the ambient number field of  \\mathcal O .   degree(O::NfOrd) -  Int   Returns the degree of  \\mathcal O .   norm_change_const(O::NfOrd) -  (Float64, Float64)   Returns  (c_1, c_2) \\in \\mathbf R_{>0}^2  such that for all  x = \\sum_{i=1}^d x_i \\omega_i \\in \\mathcal O  we have  T_2(x) \\leq c_1 \\cdot \\sum_i^d x_i^2  and  \\sum_i^d x_i^2 \\leq c_2 \\cdot T_2(x) , where  (\\omega_i)_i  is the  \\mathbf Z -basis of  \\mathcal O .", 
            "title": "Basic properties"
        }, 
        {
            "location": "/numberfields/orders/#elements", 
            "text": "", 
            "title": "Elements"
        }, 
        {
            "location": "/numberfields/orders/#ideals", 
            "text": "", 
            "title": "Ideals"
        }
    ]
}
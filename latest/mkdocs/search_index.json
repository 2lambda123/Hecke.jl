{
    "docs": [
        {
            "location": "/", 
            "text": "Hecke\n\n\nBuilds\n\n\n \n\n\n\n\nAbout\n\n\nHecke is a software package for algebraic number theory maintained by Claus Fieker and Tommy Hofmann. It is written in \njulia\n and is based on the computer algebra package \nNemo\n.\n\n\n\n\nhttps://github.com/thofma/Hecke.jl\n (Source code)\n\n\nhttp://thofma.github.io/Hecke.jl/latest/\n (Online documentation)\n\n\n\n\nSo far, Hecke provides the following features:\n\n\n\n\nOrders (including element and ideal arithmetic) in number fields\n\n\nComputation of maximal orders\n\n\nVerified residue computations of Dedekind zeta functions\n\n\nFactor base creation and relations search in number fields\n\n\nLattice enumeration\n\n\nSparse linear algebra\n\n\n\n\n\n\nInstallation\n\n\nTo use Hecke, a julia version of 0.5 or higher is necessary (the latest stable julia version will do). Please see \nhttp://julialang.org/downloads\n for instructions on how to obtain julia for your system. Once a suitable julia version is installed, use the following steps at the julia prompt to install Hecke:\n\n\njulia\n \nPkg\n.\nadd\n(\nHecke\n)\n\n\n\n\n\n\n\n\nQuick start\n\n\nHere is a quick example of using Hecke:\n\n\njulia\n \nusing\n \nHecke\n\n\n...\n\n\n\nWelcome\n \nto\n \n\n  \n_\n    \n_\n           \n_\n        \n \n|\n \n|\n  \n|\n \n|\n         \n|\n \n|\n       \n \n|\n \n|\n__\n|\n \n|\n \n___\n  \n___\n|\n \n|\n \n_____\n \n \n|\n  \n__\n  \n|/\n \n_\n \n\\/\n \n__\n|\n \n|/\n \n/\n \n_\n \n\\\n\n \n|\n \n|\n  \n|\n \n|\n  \n__\n/\n \n(\n__\n|\n   \n  \n__\n/\n\n \n|\n_\n|\n  \n|\n_\n|\\\n___\n|\\\n___\n|\n_\n|\\\n_\n\\\n___\n|\n\n\n\nVersion\n \n0.2\n.\n1\n \n...\n \n \n...\n \nwhich\n \ncomes\n \nwith\n \nabsolutely\n \nno\n \nwarrant\n \nwhatsoever\n\n\n(\nc\n)\n \n2015\n \nby\n \nClaus\n \nFieker\n \nand\n \nTommy\n \nHofmann\n\n\n\njulia\n \nQx\n,\n \nx\n \n=\n \nPolynomialRing\n(\nQQ\n,\n \nx\n);\n\n\njulia\n \nf\n \n=\n \nx\n^\n3\n \n+\n \n2\n;\n\n\njulia\n \nK\n,\n \na\n \n=\n \nNumberField\n(\nf\n,\n \na\n);\n\n\njulia\n \nO\n \n=\n \nmaximal_order\n(\nK\n);\n\n\njulia\n \nO\n\n\nMaximal\n \norder\n \nof\n \nNumber\n \nfield\n \nover\n \nRational\n \nField\n \nwith\n \ndefining\n \npolynomial\n \nx\n^\n3\n \n+\n \n2\n \n\nwith\n \nbasis\n \n[\n1\n,\na\n,\na\n^\n2\n]\n\n\n\n\n\n\n\n\nDocumentation\n\n\nThe online documentation can be found here: \nhttp://thofma.github.io/Hecke.jl/latest/\n\n\nThe documentation of the single functions can also be accessed at the julia prompt. Here is an example:\n\n\nhelp?\n signature\nsearch: signature\n\n  ----------------------------------------------------------------------------\n\n  signature(O::NfMaximalOrder) -\n Tuple{Int, Int}\n\n  |  Returns the signature of the ambient number field of \\mathcal O.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#hecke", 
            "text": "Builds", 
            "title": "Hecke"
        }, 
        {
            "location": "/#about", 
            "text": "Hecke is a software package for algebraic number theory maintained by Claus Fieker and Tommy Hofmann. It is written in  julia  and is based on the computer algebra package  Nemo .   https://github.com/thofma/Hecke.jl  (Source code)  http://thofma.github.io/Hecke.jl/latest/  (Online documentation)   So far, Hecke provides the following features:   Orders (including element and ideal arithmetic) in number fields  Computation of maximal orders  Verified residue computations of Dedekind zeta functions  Factor base creation and relations search in number fields  Lattice enumeration  Sparse linear algebra", 
            "title": "About"
        }, 
        {
            "location": "/#installation", 
            "text": "To use Hecke, a julia version of 0.5 or higher is necessary (the latest stable julia version will do). Please see  http://julialang.org/downloads  for instructions on how to obtain julia for your system. Once a suitable julia version is installed, use the following steps at the julia prompt to install Hecke:  julia   Pkg . add ( Hecke )", 
            "title": "Installation"
        }, 
        {
            "location": "/#quick-start", 
            "text": "Here is a quick example of using Hecke:  julia   using   Hecke  ...  Welcome   to  \n\n   _      _             _         \n  |   |    |   |           |   |        \n  |   | __ |   |   ___    ___ |   |   _____  \n  |    __    |/   _   \\/   __ |   |/   /   _   \\ \n  |   |    |   |    __ /   ( __ |        __ / \n  | _ |    | _ |\\ ___ |\\ ___ | _ |\\ _ \\ ___ |  Version   0.2 . 1   ...  \n  ...   which   comes   with   absolutely   no   warrant   whatsoever  ( c )   2015   by   Claus   Fieker   and   Tommy   Hofmann  julia   Qx ,   x   =   PolynomialRing ( QQ ,   x );  julia   f   =   x ^ 3   +   2 ;  julia   K ,   a   =   NumberField ( f ,   a );  julia   O   =   maximal_order ( K );  julia   O  Maximal   order   of   Number   field   over   Rational   Field   with   defining   polynomial   x ^ 3   +   2   with   basis   [ 1 , a , a ^ 2 ]", 
            "title": "Quick start"
        }, 
        {
            "location": "/#documentation", 
            "text": "The online documentation can be found here:  http://thofma.github.io/Hecke.jl/latest/  The documentation of the single functions can also be accessed at the julia prompt. Here is an example:  help?  signature\nsearch: signature\n\n  ----------------------------------------------------------------------------\n\n  signature(O::NfMaximalOrder) -  Tuple{Int, Int}\n\n  |  Returns the signature of the ambient number field of \\mathcal O.", 
            "title": "Documentation"
        }, 
        {
            "location": "/numberfields/introduction/", 
            "text": "Introduction", 
            "title": "Introduction"
        }, 
        {
            "location": "/numberfields/introduction/#introduction", 
            "text": "", 
            "title": "Introduction"
        }, 
        {
            "location": "/numberfields/orders/", 
            "text": "Creation\n\n\nOrder(::Array{nf_elem, 1}, ::Bool)\nOrder(::AnticNumberField, ::FakeFmpqMat, ::Bool)\nEquationOrder(::AnticNumberField)\n\n\n\n\n\n\n\nExample\n\n\njulia\n \nQx\n,\n \nx\n \n=\n \nPolynomialRing\n(\nQQ\n,\n \nx\n);\n\n\n\njulia\n \nK\n,\n \na\n \n=\n \nNumberField\n(\nx\n^\n2\n \n-\n \n2\n,\n \na\n);\n\n\n\njulia\n \nO\n \n=\n \nEquationOrder\n(\nK\n)\n\n\nOrder\n \nof\n \nNumber\n \nfield\n \nover\n \nRational\n \nField\n \nwith\n \ndefining\n \npolynomial\n \nx\n^\n2\n \n-\n \n2\n\n\nwith\n \nZ\n-\nbasis\n \nHecke\n.\nNfOrdElem\n[\n1\n,\na\n]\n\n\n\n\n\n\nmaximal_order(::AnticNumberField)\nmaximal_order(::AnticNumberField, ::Array{fmpz, 1})\nmake_maximal(::NfOrd)\n\n\n\n\n\njulia\n \nQx\n,\n \nx\n \n=\n \nPolynomialRing\n(\nQQ\n,\n \nx\n);\n\n\n\njulia\n \nK\n,\n \na\n \n=\n \nNumberField\n(\nx\n^\n2\n \n-\n \n2\n,\n \na\n);\n\n\n\njulia\n \nR\n \n=\n \nEquationOrder\n(\nK\n)\n\n\nOrder\n \nof\n \nNumber\n \nfield\n \nover\n \nRational\n \nField\n \nwith\n \ndefining\n \npolynomial\n \nx\n^\n2\n \n-\n \n2\n\n\nwith\n \nZ\n-\nbasis\n \nHecke\n.\nNfOrdElem\n[\n1\n,\na\n]\n\n\n\njulia\n \nT\n \n=\n \nmaximal_order\n(\nR\n)\n\n\nERROR\n:\n \nMethodError\n:\n \nno\n \nmethod\n \nmatching\n \nmaximal_order\n(\n::\nHecke\n.\nNfOrd\n)\n\n\nClosest\n \ncandidates\n \nare\n:\n\n  \nmaximal_order\n(\n!\nMatched\n::\nNemo\n.\nAnticNumberField\n,\n \n!\nMatched\n::\nArray\n{\nNemo\n.\nfmpz\n,\n1\n})\n \nat\n \n/\nhome\n/\ntravis\n/.\njulia\n/\nv0\n.\n5\n/\nHecke\n/\nsrc\n/\nNfOrd\n/\nNfOrd\n.\njl\n:\n956\n\n  \nmaximal_order\n(\n!\nMatched\n::\nNemo\n.\nAnticNumberField\n)\n \nat\n \n/\nhome\n/\ntravis\n/.\njulia\n/\nv0\n.\n5\n/\nHecke\n/\nsrc\n/\nNfOrd\n/\nNfOrd\n.\njl\n:\n930\n\n  \nmaximal_order\n{\nT\n}(\n!\nMatched\n::\nNemo\n.\nAnticNumberField\n,\n \n!\nMatched\n::\nArray\n{\nT\n,\n1\n})\n \nat\n \n/\nhome\n/\ntravis\n/.\njulia\n/\nv0\n.\n5\n/\nHecke\n/\nsrc\n/\nNfOrd\n/\nNfOrd\n.\njl\n:\n960\n\n\n\n\n\n\n\n\nBasic properties\n\n\nsignature(::NfOrd)\ndegree(::NfOrd)\nnorm_change_const(::NfOrd)\nisequationorder(::NfOrd)\nnf(::NfOrd)\nbasis(::NfOrd)\nbasis_mat(::NfOrd)\nbasis_mat_inv(::NfOrd)\ndiscriminant(::NfOrd)\ngen_index(::NfOrd)\nindex(::NfOrd)\nisindex_divisor(::NfOrd, p::Int)\nminkowski_mat(::NfOrd)\nin(::nf_elem, ::NfOrd)\nden(::nf_elem, ::NfOrd)\n+(::NfOrd, ::NfOrd)\npoverorder(::NfOrd, ::fmpz)\npmaximal_overorder(::NfOrd, ::fmpz)\n\n\n\n\n\n\n\nElements\n\n\n\n\nCreation\n\n\ncall(::NfOrd, ::nf_elem)\ncall(::NfOrd, ::fmpz)\ncall(::NfOrd, ::Array{fmpz, 1})\ncall(::NfOrd, ::Array{Int, 1})\ncall(::NfOrd)\n\n\n\n\n\n\n\nBasic properties\n\n\n\n\nparent(a::NfOrdElem) -\n NfOrd\n\n\n\n\n\n\n\nReturns the order of which \na\n is an element.\n\n\n\n\nsource\n\n\n\n\nelem_in_nf(a::NfOrdElem) -\n nf_elem\n\n\n\n\n\n\n\nReturns the element \na\n considered as an element of the ambient number field.\n\n\n\n\nsource\n\n\n\n\nelem_in_basis(a::NfOrdElem) -\n Array{fmpz, 1}\n\n\n\n\n\n\n\nReturns the coefficient vector of \na\n.\n\n\n\n\nsource\n\n\n\n\ndiscriminant(B::Array{NfOrdElem, 1}) -\n fmpz\n\n\n\n\n\n\n\nReturns the discriminant of the family \nB\n.\n\n\n\n\nsource\n\n\n\n\n==(x::NfOrdElem, y::NfOrdElem) -\n Bool\n\n\n\n\n\n\n\nReturns whether \nx\n and \ny\n are equal.\n\n\n\n\nsource\n\n\n\n\nzero(O::NfOrd) -\n NfOrdElem\n\n\n\n\n\n\n\nReturns the zero element of \n\\mathcal O\n.\n\n\n\n\nsource\n\n\n\n\none(O::NfOrd) -\n NfOrdElem\n\n\n\n\n\n\n\nReturns the zero element of \n\\mathcal O\n.\n\n\n\n\nsource\n\n\n\n\niszero(a::NfOrd) -\n Bool\n\n\n\n\n\n\n\nTests if \na\n is one.\n\n\n\n\nsource\n\n\n\n\nisone(a::NfOrd) -\n Bool\n\n\n\n\n\n\n\nTests if \na\n is one.\n\n\n\n\nsource\n\n\n\n\nArithmetic\n\n\n\n\n-(x::NfOrdElem) -\n NfOrdElem\n\n\n\n\n\n\n\nReturns the additive inverse of \nx\n.\n\n\n\n\nsource\n\n\n\n\n+(x::NfOrdElem, y::NfOrdElem) -\n NfOrdElem\n\n\n\n\n\n\n\nReturns \nx + y\n.\n\n\n\n\nsource\n\n\n\n\n-(x::NfOrdElem, y::NfOrdElem) -\n NfOrdElem\n\n\n\n\n\n\n\nReturns \nx - y\n.\n\n\n\n\nsource\n\n\n\n\n*(x::NfOrdElem, y::NfOrdElem) -\n NfOrdElem\n\n\n\n\n\n\n\nReturns \nx \\cdot y\n.\n\n\n\n\nsource\n\n\n\n\n^(x::NfOrdElem, y::Union{fmpz, Int})\n\n\n\n\n\n\n\nReturns \nx^y\n.\n\n\n\n\nsource\n\n\n\n\nmod(a::NfOrdElem, m::Union{fmpz, Int}) -\n NfOrdElem\n\n\n\n\n\n\n\nReduces the coefficient vector of \na\n modulo \nm\n and returns the corresponding element. The coefficient vector of the result will have entries \nx\n with \n0 \\leq x \\leq m\n.\n\n\n\n\nsource\n\n\n\n\npowermod(a::NfOrdElem, i::fmpz, m::Integer) -\n NfOrdElem\n\n\n\n\n\n\n\nReturns the element \na^i\n modulo \nm\n.\n\n\n\n\nsource\n\n\n\n\nMiscallenous\n\n\n\n\nrepresentation_mat(a::NfOrdElem) -\n fmpz_mat\n\n\n\n\n\n\n\nReturns the representation matrix of the element \na\n.\n\n\n\n\nsource\n\n\n\n\nrepresentation_mat(a::NfOrdElem, K::AnticNumberField) -\n FakeFmpqMat\n\n\n\n\n\n\n\nReturns the representation matrix of the element \na\n considered as an element of the ambient number field \nK\n. It is assumed that \nK\n is the ambient number field of the order of \na\n.\n\n\n\n\nsource\n\n\n\n\ntrace(a::NfOrdElem) -\n fmpz\n\n\n\n\n\n\n\nReturns the trace of \na\n.\n\n\n\n\nsource\n\n\n\n\nnorm(a::NfOrdElem) -\n fmpz\n\n\n\n\n\n\n\nReturns the norm of \na\n.\n\n\n\n\nsource\n\n\n\n\nrand(O::NfOrd, n::Union{Integer, fmpz}) -\n NfOrdElem\n\n\n\n\n\n\n\nComputes a coefficient vector with entries uniformly distributed in \n\\{-n,\\dotsc,-1,0,1,\\dotsc,n\\}\n and returns the corresponding element of the order \n\\mathcal O\n.\n\n\n\n\nsource\n\n\n\n\nminkowski_map(a::NfOrdElem, abs_tol::Int) -\n Array{arb, 1}\n\n\n\n\n\n\n\nReturns the image of \na\n under the Minkowski embedding. Every entry of the array returned is of type \narb\n with radius less then \n2^-abs_tol\n.\n\n\n\n\nsource\n\n\n\n\nconjugates_arb(x::NfOrdElem, abs_tol::Int) -\n Array{acb, 1}\n\n\n\n\n\n\n\nCompute the the conjugates of \nx\n as elements of type \nacb\n. Recall that we order the complex conjugates \n\\sigma_{r+1}(x),...,\\sigma_{r+2s}(x)\n such that \n\\sigma_{i}(x) = \\overline{\\sigma_{i + s}(x)}\n for \nr + 2 \\leq i \\leq r + s\n.\n\n\nEvery entry \ny\n of the array returned satisfies \nradius(real(y)) \n 2^-abs_tol\n, \nradius(imag(y)) \n 2^-abs_tol\n respectively.\n\n\n\n\nsource\n\n\n\n\nconjugates_arb_log(x::NfOrdElem, abs_tol::Int) -\n Array{arb, 1}\n\n\n\n\n\n\n\nReturns the elements \n(\\log(\\lvert \\sigma_1(x) \\rvert),\\dotsc,\\log(\\lvert\\sigma_r(x) \\rvert), \\dotsc,2\\log(\\lvert \\sigma_{r+1}(x) \\rvert),\\dotsc, 2\\log(\\lvert \\sigma_{r+s}(x)\\rvert))\n as elements of type \narb\n radius less then \n2^-abs_tol\n.\n\n\n\n\nsource\n\n\n\n\nt2(x::NfOrdElem, abs_tol::Int = 32) -\n arb\n\n\n\n\n\n\n\nReturn the \nT_2\n-norm of \nx\n. The radius of the result will be less than \n2^-abs_tol\n.\n\n\n\n\nsource\n\n\n\n\nIdeals\n\n\n\n\nCreation\n\n\n\n\nideal(O::NfOrd, a::Int) -\n NfOrdIdl\n\n\n\n\n\n\n\nReturns the ideal of \n\\mathcal O\n which is generated by \na\n.\n\n\n\n\nsource\n\n\n\n\nideal(O::NfOrd, a::fmpz) -\n NfOrdIdl\n\n\n\n\n\n\n\nReturns the ideal of \n\\mathcal O\n which is generated by \na\n.\n\n\n\n\nsource\n\n\n\n\nideal(O::NfOrd, x::fmpz_mat, check::Bool = false) -\n NfOrdIdl\n\n\n\n\n\n\n\nCreates the ideal of \n\\mathcal O\n with basis matrix \nx\n. If check is set, then it is checked whether \nx\n defines an ideal (expensive).\n\n\n\n\nsource\n\n\n\n\nideal(O::NfOrd, x::NfOrdElem) -\n NfOrdIdl\n\n\n\n\n\n\n\nCreates the principal ideal \n(x)\n of \n\\mathcal O\n.\n\n\n\n\nsource\n\n\n\n\nring_of_multipliers(I::NfOrdIdl) -\n NfOrd\n\n\n\n\n\n\n\nComputes the order \n(I : I)\n, which is the set of all \nx \\in K\n with \nxI \\subseteq I\n.\n\n\n\n\nsource\n\n\n*(O::NfOrd, x::NfOrdElem) -\n NfOrdIdl\n*(x::NfOrdElem, O::NfOrd) -\n NfOrdIdl\n\n\n\n\n\n\n\nReturns the principal ideal \n(x)\n of \n\\mathcal O\n.\n\n\n\n\nsource\n\n\n\n\nArithmetic\n\n\n\n\n==(x::NfOrdIdl, y::NfOrdIdl)\n\n\n\n\n\n\n\nReturns whether \nx\n and \ny\n are equal.\n\n\n\n\nsource\n\n\n\n\n+(x::NfOrdIdl, y::NfOrdIdl)\n\n\n\n\n\n\n\nReturns \nx + y\n.\n\n\n\n\nsource\n\n\n*(x::NfOrdIdl, y::NfOrdIdl)\n\n\n\n\n\n\n\nReturns \nx \\cdot y\n.\n\n\n\n\nsource\n\n\nintersection(x::NfOrdIdl, y::NfOrdIdl) -\n NfOrdIdl\nlcm(x::NfOrdIdl, y::NfOrdIdl) -\n NfOrdIdl\n\n\n\n\n\n\n\nReturns \nx \\cap y\n.\n\n\n\n\nsource\n\n\n\n\nMiscaellenous\n\n\n\n\nparent(I::NfOrdIdl) -\n NfOrd\n\n\n\n\n\n\n\nReturns the order of \nI\n.\n\n\n\n\nsource\n\n\n\n\nbasis(A::NfOrdIdl) -\n Array{NfOrdElem, 1}\n\n\n\n\n\n\n\nReturns the basis of A.\n\n\n\n\nsource\n\n\n\n\nbasis_mat(A::NfOrdIdl) -\n fmpz_mat\n\n\n\n\nReturns the basis matrix of \nA\n.\n\n\n\n\nsource\n\n\n\n\nbasis_mat_inv(A::NfOrdIdl) -\n fmpz_mat\n\n\n\n\nReturns the inverse basis matrix of \nA\n.\n\n\n\n\nsource\n\n\n\n\nminimum(A::NfOrdIdl) -\n fmpz\n\n\n\n\n\n\n\nReturns the smallest nonnegative element in \nA \\cap \\mathbf Z\n.\n\n\n\n\nsource\n\n\n\n\nnorm(A::NfOrdIdl) -\n fmpz\n\n\n\n\n\n\n\nReturns the norm of \nA\n, that is, the cardinality of \n\\mathcal O/A\n, where \n\\mathcal O\n is the order of \nA\n.\n\n\n\n\nsource\n\n\n\n\nin(x::NfOrdElem, y::NfOrdIdl)\nin(x::nf_elem, y::NfOrdIdl)\nin(x::fmpz, y::NfOrdIdl)\n\n\n\n\n\n\n\nReturns whether \nx\n is contained in \ny\n.\n\n\n\n\nsource\n\n\nidempotents(x::NfOrdIdl, y::NfOrdIdl) -\n NfOrdElem, NfOrdElem\n\n\n\n\n\n\n\nReturns a tuple \n(e, f)\n consisting of elements \ne in x\n, \nf in y\n such that \n1 = e + f\n.\n\n\nIf the ideals are not coprime, an error is raised.\n\n\n\n\nsource\n\n\n\n\nmod(x::NfOrdElem, I::NfOrdIdl)\n\n\n\n\n\n\n\nReturns the unique element \ny\n of the ambient order of \nx\n with \nx \\equiv y \\bmod I\n and the following property: If \na_1,\\dotsc,a_d \\in \\Z_{\\geq 1}\n are the diagonal entries of the unique HNF basis matrix of \nI\n and \n(b_1,\\dotsc,b_d)\n is the coefficient vector of \ny\n, then \n0 \\leq b_i < a_i\n for \n1 \\leq i \\leq d\n.\n\n\n\n\nsource\n\n\n\n\npradical(O::NfOrd, p::fmpz) -\n NfOrdIdl\n\n\n\n\n\n\n\nGiven a prime number \np\n, this function returns the \np\n-radical \n\\sqrt{p\\mathcal O}\n of \n\\mathcal O\n, which is just \n\\{ x \\in \\mathcal O \\mid \\exists k \\in \\mathbf Z_{\\geq 0} \\colon x^k \\in p\\mathcal O \\}\n. It is not checked that \np\n is prime.\n\n\n\n\nsource\n\n\n\n\nFractional ideals\n\n\n\n\nCreation\n\n\nfrac_ideal(::NfOrd, ::fmpz_mat)\nfrac_ideal(::NfOrd, ::fmpz_mat, ::fmpz)\nfrac_ideal(::NfOrd, ::FakeFmpqMat)\nfrac_ideal(::NfOrd, ::NfOrdIdl)\nfrac_ideal(::NfOrd, ::NfOrdIdl, ::fmpz)\nfrac_ideal(::NfOrd, ::nf_elem)\nfrac_ideal(::NfOrd, ::NfOrdElem)\n\n\n\n\n\n\n\nArithmetic\n\n\n\n\n==(x::NfOrdFracIdl, y::NfOrdFracIdl) -\n Bool\n\n\n\n\n\n\n\nReturns whether \nx\n and \ny\n are equal.\n\n\n\n\nsource\n\n\n\n\nMiscaellenous\n\n\norder(::NfOrdFracIdl)\nbasis_mat(::NfOrdFracIdl)\nbasis_mat_inv(::NfOrdFracIdl)\nbasis(::NfOrdFracIdl)\nnorm(::NfOrdFracIdl)", 
            "title": "Orders"
        }, 
        {
            "location": "/numberfields/orders/#creation", 
            "text": "Order(::Array{nf_elem, 1}, ::Bool)\nOrder(::AnticNumberField, ::FakeFmpqMat, ::Bool)\nEquationOrder(::AnticNumberField)", 
            "title": "Creation"
        }, 
        {
            "location": "/numberfields/orders/#example", 
            "text": "julia   Qx ,   x   =   PolynomialRing ( QQ ,   x );  julia   K ,   a   =   NumberField ( x ^ 2   -   2 ,   a );  julia   O   =   EquationOrder ( K )  Order   of   Number   field   over   Rational   Field   with   defining   polynomial   x ^ 2   -   2  with   Z - basis   Hecke . NfOrdElem [ 1 , a ]   maximal_order(::AnticNumberField)\nmaximal_order(::AnticNumberField, ::Array{fmpz, 1})\nmake_maximal(::NfOrd)  julia   Qx ,   x   =   PolynomialRing ( QQ ,   x );  julia   K ,   a   =   NumberField ( x ^ 2   -   2 ,   a );  julia   R   =   EquationOrder ( K )  Order   of   Number   field   over   Rational   Field   with   defining   polynomial   x ^ 2   -   2  with   Z - basis   Hecke . NfOrdElem [ 1 , a ]  julia   T   =   maximal_order ( R )  ERROR :   MethodError :   no   method   matching   maximal_order ( :: Hecke . NfOrd )  Closest   candidates   are : \n   maximal_order ( ! Matched :: Nemo . AnticNumberField ,   ! Matched :: Array { Nemo . fmpz , 1 })   at   / home / travis /. julia / v0 . 5 / Hecke / src / NfOrd / NfOrd . jl : 956 \n   maximal_order ( ! Matched :: Nemo . AnticNumberField )   at   / home / travis /. julia / v0 . 5 / Hecke / src / NfOrd / NfOrd . jl : 930 \n   maximal_order { T }( ! Matched :: Nemo . AnticNumberField ,   ! Matched :: Array { T , 1 })   at   / home / travis /. julia / v0 . 5 / Hecke / src / NfOrd / NfOrd . jl : 960", 
            "title": "Example"
        }, 
        {
            "location": "/numberfields/orders/#basic-properties", 
            "text": "signature(::NfOrd)\ndegree(::NfOrd)\nnorm_change_const(::NfOrd)\nisequationorder(::NfOrd)\nnf(::NfOrd)\nbasis(::NfOrd)\nbasis_mat(::NfOrd)\nbasis_mat_inv(::NfOrd)\ndiscriminant(::NfOrd)\ngen_index(::NfOrd)\nindex(::NfOrd)\nisindex_divisor(::NfOrd, p::Int)\nminkowski_mat(::NfOrd)\nin(::nf_elem, ::NfOrd)\nden(::nf_elem, ::NfOrd)\n+(::NfOrd, ::NfOrd)\npoverorder(::NfOrd, ::fmpz)\npmaximal_overorder(::NfOrd, ::fmpz)", 
            "title": "Basic properties"
        }, 
        {
            "location": "/numberfields/orders/#elements", 
            "text": "", 
            "title": "Elements"
        }, 
        {
            "location": "/numberfields/orders/#creation_1", 
            "text": "call(::NfOrd, ::nf_elem)\ncall(::NfOrd, ::fmpz)\ncall(::NfOrd, ::Array{fmpz, 1})\ncall(::NfOrd, ::Array{Int, 1})\ncall(::NfOrd)", 
            "title": "Creation"
        }, 
        {
            "location": "/numberfields/orders/#basic-properties_1", 
            "text": "parent(a::NfOrdElem) -  NfOrd   Returns the order of which  a  is an element.   source   elem_in_nf(a::NfOrdElem) -  nf_elem   Returns the element  a  considered as an element of the ambient number field.   source   elem_in_basis(a::NfOrdElem) -  Array{fmpz, 1}   Returns the coefficient vector of  a .   source   discriminant(B::Array{NfOrdElem, 1}) -  fmpz   Returns the discriminant of the family  B .   source   ==(x::NfOrdElem, y::NfOrdElem) -  Bool   Returns whether  x  and  y  are equal.   source   zero(O::NfOrd) -  NfOrdElem   Returns the zero element of  \\mathcal O .   source   one(O::NfOrd) -  NfOrdElem   Returns the zero element of  \\mathcal O .   source   iszero(a::NfOrd) -  Bool   Tests if  a  is one.   source   isone(a::NfOrd) -  Bool   Tests if  a  is one.   source", 
            "title": "Basic properties"
        }, 
        {
            "location": "/numberfields/orders/#arithmetic", 
            "text": "-(x::NfOrdElem) -  NfOrdElem   Returns the additive inverse of  x .   source   +(x::NfOrdElem, y::NfOrdElem) -  NfOrdElem   Returns  x + y .   source   -(x::NfOrdElem, y::NfOrdElem) -  NfOrdElem   Returns  x - y .   source   *(x::NfOrdElem, y::NfOrdElem) -  NfOrdElem   Returns  x \\cdot y .   source   ^(x::NfOrdElem, y::Union{fmpz, Int})   Returns  x^y .   source   mod(a::NfOrdElem, m::Union{fmpz, Int}) -  NfOrdElem   Reduces the coefficient vector of  a  modulo  m  and returns the corresponding element. The coefficient vector of the result will have entries  x  with  0 \\leq x \\leq m .   source   powermod(a::NfOrdElem, i::fmpz, m::Integer) -  NfOrdElem   Returns the element  a^i  modulo  m .   source", 
            "title": "Arithmetic"
        }, 
        {
            "location": "/numberfields/orders/#miscallenous", 
            "text": "representation_mat(a::NfOrdElem) -  fmpz_mat   Returns the representation matrix of the element  a .   source   representation_mat(a::NfOrdElem, K::AnticNumberField) -  FakeFmpqMat   Returns the representation matrix of the element  a  considered as an element of the ambient number field  K . It is assumed that  K  is the ambient number field of the order of  a .   source   trace(a::NfOrdElem) -  fmpz   Returns the trace of  a .   source   norm(a::NfOrdElem) -  fmpz   Returns the norm of  a .   source   rand(O::NfOrd, n::Union{Integer, fmpz}) -  NfOrdElem   Computes a coefficient vector with entries uniformly distributed in  \\{-n,\\dotsc,-1,0,1,\\dotsc,n\\}  and returns the corresponding element of the order  \\mathcal O .   source   minkowski_map(a::NfOrdElem, abs_tol::Int) -  Array{arb, 1}   Returns the image of  a  under the Minkowski embedding. Every entry of the array returned is of type  arb  with radius less then  2^-abs_tol .   source   conjugates_arb(x::NfOrdElem, abs_tol::Int) -  Array{acb, 1}   Compute the the conjugates of  x  as elements of type  acb . Recall that we order the complex conjugates  \\sigma_{r+1}(x),...,\\sigma_{r+2s}(x)  such that  \\sigma_{i}(x) = \\overline{\\sigma_{i + s}(x)}  for  r + 2 \\leq i \\leq r + s .  Every entry  y  of the array returned satisfies  radius(real(y))   2^-abs_tol ,  radius(imag(y))   2^-abs_tol  respectively.   source   conjugates_arb_log(x::NfOrdElem, abs_tol::Int) -  Array{arb, 1}   Returns the elements  (\\log(\\lvert \\sigma_1(x) \\rvert),\\dotsc,\\log(\\lvert\\sigma_r(x) \\rvert), \\dotsc,2\\log(\\lvert \\sigma_{r+1}(x) \\rvert),\\dotsc, 2\\log(\\lvert \\sigma_{r+s}(x)\\rvert))  as elements of type  arb  radius less then  2^-abs_tol .   source   t2(x::NfOrdElem, abs_tol::Int = 32) -  arb   Return the  T_2 -norm of  x . The radius of the result will be less than  2^-abs_tol .   source", 
            "title": "Miscallenous"
        }, 
        {
            "location": "/numberfields/orders/#ideals", 
            "text": "", 
            "title": "Ideals"
        }, 
        {
            "location": "/numberfields/orders/#creation_2", 
            "text": "ideal(O::NfOrd, a::Int) -  NfOrdIdl   Returns the ideal of  \\mathcal O  which is generated by  a .   source   ideal(O::NfOrd, a::fmpz) -  NfOrdIdl   Returns the ideal of  \\mathcal O  which is generated by  a .   source   ideal(O::NfOrd, x::fmpz_mat, check::Bool = false) -  NfOrdIdl   Creates the ideal of  \\mathcal O  with basis matrix  x . If check is set, then it is checked whether  x  defines an ideal (expensive).   source   ideal(O::NfOrd, x::NfOrdElem) -  NfOrdIdl   Creates the principal ideal  (x)  of  \\mathcal O .   source   ring_of_multipliers(I::NfOrdIdl) -  NfOrd   Computes the order  (I : I) , which is the set of all  x \\in K  with  xI \\subseteq I .   source  *(O::NfOrd, x::NfOrdElem) -  NfOrdIdl\n*(x::NfOrdElem, O::NfOrd) -  NfOrdIdl   Returns the principal ideal  (x)  of  \\mathcal O .   source", 
            "title": "Creation"
        }, 
        {
            "location": "/numberfields/orders/#arithmetic_1", 
            "text": "==(x::NfOrdIdl, y::NfOrdIdl)   Returns whether  x  and  y  are equal.   source   +(x::NfOrdIdl, y::NfOrdIdl)   Returns  x + y .   source  *(x::NfOrdIdl, y::NfOrdIdl)   Returns  x \\cdot y .   source  intersection(x::NfOrdIdl, y::NfOrdIdl) -  NfOrdIdl\nlcm(x::NfOrdIdl, y::NfOrdIdl) -  NfOrdIdl   Returns  x \\cap y .   source", 
            "title": "Arithmetic"
        }, 
        {
            "location": "/numberfields/orders/#miscaellenous", 
            "text": "parent(I::NfOrdIdl) -  NfOrd   Returns the order of  I .   source   basis(A::NfOrdIdl) -  Array{NfOrdElem, 1}   Returns the basis of A.   source   basis_mat(A::NfOrdIdl) -  fmpz_mat   Returns the basis matrix of  A .   source   basis_mat_inv(A::NfOrdIdl) -  fmpz_mat   Returns the inverse basis matrix of  A .   source   minimum(A::NfOrdIdl) -  fmpz   Returns the smallest nonnegative element in  A \\cap \\mathbf Z .   source   norm(A::NfOrdIdl) -  fmpz   Returns the norm of  A , that is, the cardinality of  \\mathcal O/A , where  \\mathcal O  is the order of  A .   source   in(x::NfOrdElem, y::NfOrdIdl)\nin(x::nf_elem, y::NfOrdIdl)\nin(x::fmpz, y::NfOrdIdl)   Returns whether  x  is contained in  y .   source  idempotents(x::NfOrdIdl, y::NfOrdIdl) -  NfOrdElem, NfOrdElem   Returns a tuple  (e, f)  consisting of elements  e in x ,  f in y  such that  1 = e + f .  If the ideals are not coprime, an error is raised.   source   mod(x::NfOrdElem, I::NfOrdIdl)   Returns the unique element  y  of the ambient order of  x  with  x \\equiv y \\bmod I  and the following property: If  a_1,\\dotsc,a_d \\in \\Z_{\\geq 1}  are the diagonal entries of the unique HNF basis matrix of  I  and  (b_1,\\dotsc,b_d)  is the coefficient vector of  y , then  0 \\leq b_i < a_i  for  1 \\leq i \\leq d .   source   pradical(O::NfOrd, p::fmpz) -  NfOrdIdl   Given a prime number  p , this function returns the  p -radical  \\sqrt{p\\mathcal O}  of  \\mathcal O , which is just  \\{ x \\in \\mathcal O \\mid \\exists k \\in \\mathbf Z_{\\geq 0} \\colon x^k \\in p\\mathcal O \\} . It is not checked that  p  is prime.   source", 
            "title": "Miscaellenous"
        }, 
        {
            "location": "/numberfields/orders/#fractional-ideals", 
            "text": "", 
            "title": "Fractional ideals"
        }, 
        {
            "location": "/numberfields/orders/#creation_3", 
            "text": "frac_ideal(::NfOrd, ::fmpz_mat)\nfrac_ideal(::NfOrd, ::fmpz_mat, ::fmpz)\nfrac_ideal(::NfOrd, ::FakeFmpqMat)\nfrac_ideal(::NfOrd, ::NfOrdIdl)\nfrac_ideal(::NfOrd, ::NfOrdIdl, ::fmpz)\nfrac_ideal(::NfOrd, ::nf_elem)\nfrac_ideal(::NfOrd, ::NfOrdElem)", 
            "title": "Creation"
        }, 
        {
            "location": "/numberfields/orders/#arithmetic_2", 
            "text": "==(x::NfOrdFracIdl, y::NfOrdFracIdl) -  Bool   Returns whether  x  and  y  are equal.   source", 
            "title": "Arithmetic"
        }, 
        {
            "location": "/numberfields/orders/#miscaellenous_1", 
            "text": "order(::NfOrdFracIdl)\nbasis_mat(::NfOrdFracIdl)\nbasis_mat_inv(::NfOrdFracIdl)\nbasis(::NfOrdFracIdl)\nnorm(::NfOrdFracIdl)", 
            "title": "Miscaellenous"
        }, 
        {
            "location": "/numberfields/maximalorders/", 
            "text": "Ideals\n\n\n\n\ninv(A::NfOrdIdl) -\n NfOrdFracIdl\n\n\n\n\n\n\n\nComputes the inverse of A, that is, the fractional ideal \nB\n such that \nAB = \\mathcal O_K\n.\n\n\n\n\nsource\n\n\n\n\nvaluation(a::nf_elem, p::NfOrdIdl) -\n fmpz\nvaluation(a::NfOrdElem, p::NfOrdIdl) -\n fmpz\nvaluation(a::fmpz, p::NfOrdIdl) -\n fmpz\n\n\n\n\n\n\n\nComputes the \n\\mathfrak p\n-adic valuation of \na\n, that is, the largest \ni\n such that \na\n is contained in \n\\mathfrak p^i\n.\n\n\n\n\nsource\n\n\n\n\nvaluation(A::NfOrdIdl, p::NfOrdIdl) -\n fmpz\n\n\n\n\n\n\n\nComputes the \n\\mathfrak p\n-adic valuation of \nA\n, that is, the largest \ni\n such that \nA\n is contained in \n\\mathfrak p^i\n.\n\n\n\n\nsource\n\n\n\n\nisramified(O::NfOrd, p::Int) -\n Bool\n\n\n\n\n\n\n\nReturns whether the integer \np\n is ramified in \n\\mathcal O\n. It is assumed that \np\n is prime.\n\n\n\n\nsource\n\n\n\n\nprime_decomposition(O::NfOrd,\n                    p::Integer,\n                    degree_limit::Int = 0,\n                    lower_limit::Int = 0) -\n Array{Tuple{NfOrdIdl, Int}, 1}\n\n\n\n\n\n\n\nReturns an array of tuples \n(\\mathfrak p_i,e_i)\n such that \np \\mathcal O\n is the product of the \n\\mathfrak p_i^{e_i}\n and \n\\mathfrak p_i \\neq \\mathfrak p_j\n for \ni \\neq j\n.\n\n\nIf \ndegree_limit\n is a nonzero integer \nk > 0\n, then only those prime ideals \n\\mathfrak p\n with \n\\deg(\\mathfrak p) \\leq k\n will be returned. Similarly if \n\\lower_limit\n is a nonzero integer \nl > 0\n, then only those prime ideals \n\\mathfrak p\n with \nl \\leq \\deg(\\mathfrak p)\n will be returned. Note that in this case it may happen that \np\\mathcal O\n is not the product of the \n\\mathfrak p_i^{e_i}\n.\n\n\n\n\nsource\n\n\n\n\nprime_ideals_up_to\n(\nO\n::\nNfOrd\n,\n\n                   \nB\n::\nInt\n;\n\n                   \ndegree_limit\n::\nInt\n \n=\n \n0\n)\n \n-\n \nArray\n{\nNfOrdIdl,\n \n1\n}\n\n\n\n\n\n\n\n\nComputes the prime ideals \n\\mathcal O\n with norm up to \nB\n.\n\n\nIf \ndegree_limit\n is a nonzero integer \nk\n, then prime ideals \n\\mathfrak p\n with \n\\deg(\\mathfrak p) > k\n will be discarded.\n\n\n\n\nsource\n\n\n\n\nfactor(A::NfOrdIdl) -\n Dict{NfOrdIdl, Int}\n\n\n\n\n\n\n\nComputes the prime ideal factorization \nA\n as a dictionary, the keys being the prime ideal divisors: If \nlp = factor_dict(A)\n, then \nkeys(lp)\n are the prime ideal divisors of A and \nlp[P]\n is the \nP\n-adic valuation of \nA\n for all \nP\n in \nkeys(lp)\n.\n\n\n\n\nsource\n\n\n\n\ndivexact(A::NfOrdIdl, y::fmpz) -\n NfOrdIdl\n\n\n\n\n\n\n\nReturns \nA/y\n assuming that \nA/y\n is again an integral ideal.\n\n\n\n\nsource\n\n\n\n\ndivexact(A::NfOrdIdl, B::NfOrdIdl) -\n NfOrdIdl\n\n\n\n\n\n\n\nReturns \nAB^{-1}\n assuming that \nAB^{-1}\n is again an integral ideal.\n\n\n\n\nsource\n\n\n\n\nFractional ideals\n\n\n\n\n*(I::NfOrdFracIdl, J::NfOrdFracIdl) -\n NfOrdFracIdl\n\n\n\n\n\n\n\nReturns \nIJ\n.\n\n\n\n\nsource\n\n\n\n\ninv(A::NfOrdFracIdl) -\n NfOrdFracIdl\n\n\n\n\n\n\n\nReturns the fractional ideal \nB\n such that \nAB = \\mathcal O\n.\n\n\n\n\nsource\n\n\n\n\nClass and unit group\n\n\nunit_rank(::NfOrd)\nisunit(::NfOrdElem)\nistorsion_unit(::NfOrdElem)\ntorsion_unit_order(::NfOrdElem)\ntorsion_units(::NfOrd)\ntorsion_units_gen(::NfOrd)\nisindependent(::NfOrdElem)\nregulator(::Array{NfOrdElem, 1})\nunit_group(::NfOrd)\n\n\n\n\n\n\n\nResidue rings\n\n\n\n\nResidue fields", 
            "title": "Maximal Orders"
        }, 
        {
            "location": "/numberfields/maximalorders/#ideals", 
            "text": "inv(A::NfOrdIdl) -  NfOrdFracIdl   Computes the inverse of A, that is, the fractional ideal  B  such that  AB = \\mathcal O_K .   source   valuation(a::nf_elem, p::NfOrdIdl) -  fmpz\nvaluation(a::NfOrdElem, p::NfOrdIdl) -  fmpz\nvaluation(a::fmpz, p::NfOrdIdl) -  fmpz   Computes the  \\mathfrak p -adic valuation of  a , that is, the largest  i  such that  a  is contained in  \\mathfrak p^i .   source   valuation(A::NfOrdIdl, p::NfOrdIdl) -  fmpz   Computes the  \\mathfrak p -adic valuation of  A , that is, the largest  i  such that  A  is contained in  \\mathfrak p^i .   source   isramified(O::NfOrd, p::Int) -  Bool   Returns whether the integer  p  is ramified in  \\mathcal O . It is assumed that  p  is prime.   source   prime_decomposition(O::NfOrd,\n                    p::Integer,\n                    degree_limit::Int = 0,\n                    lower_limit::Int = 0) -  Array{Tuple{NfOrdIdl, Int}, 1}   Returns an array of tuples  (\\mathfrak p_i,e_i)  such that  p \\mathcal O  is the product of the  \\mathfrak p_i^{e_i}  and  \\mathfrak p_i \\neq \\mathfrak p_j  for  i \\neq j .  If  degree_limit  is a nonzero integer  k > 0 , then only those prime ideals  \\mathfrak p  with  \\deg(\\mathfrak p) \\leq k  will be returned. Similarly if  \\lower_limit  is a nonzero integer  l > 0 , then only those prime ideals  \\mathfrak p  with  l \\leq \\deg(\\mathfrak p)  will be returned. Note that in this case it may happen that  p\\mathcal O  is not the product of the  \\mathfrak p_i^{e_i} .   source   prime_ideals_up_to ( O :: NfOrd , \n                    B :: Int ; \n                    degree_limit :: Int   =   0 )   -   Array { NfOrdIdl,   1 }    Computes the prime ideals  \\mathcal O  with norm up to  B .  If  degree_limit  is a nonzero integer  k , then prime ideals  \\mathfrak p  with  \\deg(\\mathfrak p) > k  will be discarded.   source   factor(A::NfOrdIdl) -  Dict{NfOrdIdl, Int}   Computes the prime ideal factorization  A  as a dictionary, the keys being the prime ideal divisors: If  lp = factor_dict(A) , then  keys(lp)  are the prime ideal divisors of A and  lp[P]  is the  P -adic valuation of  A  for all  P  in  keys(lp) .   source   divexact(A::NfOrdIdl, y::fmpz) -  NfOrdIdl   Returns  A/y  assuming that  A/y  is again an integral ideal.   source   divexact(A::NfOrdIdl, B::NfOrdIdl) -  NfOrdIdl   Returns  AB^{-1}  assuming that  AB^{-1}  is again an integral ideal.   source", 
            "title": "Ideals"
        }, 
        {
            "location": "/numberfields/maximalorders/#fractional-ideals", 
            "text": "*(I::NfOrdFracIdl, J::NfOrdFracIdl) -  NfOrdFracIdl   Returns  IJ .   source   inv(A::NfOrdFracIdl) -  NfOrdFracIdl   Returns the fractional ideal  B  such that  AB = \\mathcal O .   source", 
            "title": "Fractional ideals"
        }, 
        {
            "location": "/numberfields/maximalorders/#class-and-unit-group", 
            "text": "unit_rank(::NfOrd)\nisunit(::NfOrdElem)\nistorsion_unit(::NfOrdElem)\ntorsion_unit_order(::NfOrdElem)\ntorsion_units(::NfOrd)\ntorsion_units_gen(::NfOrd)\nisindependent(::NfOrdElem)\nregulator(::Array{NfOrdElem, 1})\nunit_group(::NfOrd)", 
            "title": "Class and unit group"
        }, 
        {
            "location": "/numberfields/maximalorders/#residue-rings", 
            "text": "", 
            "title": "Residue rings"
        }, 
        {
            "location": "/numberfields/maximalorders/#residue-fields", 
            "text": "", 
            "title": "Residue fields"
        }
    ]
}
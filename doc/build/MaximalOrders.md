<!-- Generated by Docile.jl -->

# Introduction

In Hecke, maximal orders (aka ring of integers), due to their special properties normal orders don't share, come with their own type `NfMaximalOrder`.  While the elements have type `NfOrderElem`, the ideals and fractional ideals have types `NfMaximalOrderIdeal` and `NfMaximalOrderFracIdeal` respectively.

While theoretically a number field contains a unique maximal order (the set of all integral elements), for technical reasons in Hecke a number field admits multiple maximal orders, which are uniquely determined by the number field and a chosen integral basis.

Let $K$ be a number field of degree $d$ with primitive element $\alpha$ and $\mathcal O$ a maximal order $K$ with $\mathbf{Z}$-basis $(\omega_1,\dotsc,\omega_d)$. The *basis matrix* of $\mathcal O$ is the unique matrix $M_{\mathcal O} \in \operatorname{Mat}_{d \times d}(\mathbf{Q})$ such that \begin{align} \begin{pmatrix} \omega_1 \\ \omega_2 \\ \vdots \\ \omega_d \end{pmatrix} = M_{\mathcal O} \begin{pmatrix} 1 \\ \alpha \\ \vdots \\ \alpha^{d - 1} \end{pmatrix} \end{align}. If $\beta$ is an element of $\mathcal O$, we call the unique integers $(x_1,\dotsc,x_d) \in \mathbf Z^d$ with \begin{align} \beta = \sum_{i=1}^d x_i \omega_i \end{align} the *coefficients* of $\beta$ with respect to $\mathcal O$ or just the *coefficient vector*.

For an ideal $I$ of $\mathcal O$, a *basis matrix* of $I$ is a matrix $M \in \operatorname{Mat}_{d \times d}(\mathbf{Z})$, such that the elements $(\alpha_1,\dotsc,\alpha_d)$ definied by \begin{align} \begin{pmatrix} \alpha_1 \\ \alpha_2 \\ \vdots \\ \alpha_d \end{pmatrix} = M_{\mathcal O} \begin{pmatrix} \omega_1 \\ \omega_2 \\ \vdots \\ \omega_d \end{pmatrix} \end{align} form a $\mathbf{Z}$-basis of $I$.

## Creation

<a name="MaximalOrder(K::Nemo.AnticNumberField) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/NfMaximalOrder.jl:225"></a>

---

```
MaximalOrder(K::AnticNumberField) -> NfMaximalOrder
```

> Returns the maximal order of $K$.


##### Example

```
julia> Qx, x = QQ["x"]
julia> K, a = NumberField(x^3 + 2, "a")
julia> O = MaximalOrder(K)
```

<a name="MaximalOrder(K::Nemo.AnticNumberField, primes::Array{Nemo.fmpz,1}) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/NfMaximalOrder.jl:241"></a>

---

```
MaximalOrder(K::AnticNumberField, primes::Array{fmpz, 1}) -> NfMaximalOrder
```

> Assuming that `primes` contains all the prime numbers at which the equation order $\mathbf{Z}[\alpha]$ of $K = \mathbf{Q}(\alpha)$ is not maximal, this function returns the maximal order of $K$.


## Basic invariants

<a name="nf(O::Hecke.NfMaximalOrder) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/NfMaximalOrder.jl:79"></a>

---

```
nf(O::NfMaximalOrder) -> AnticNumberField
```

> Returns the ambient number field of $\mathcal O$.


<a name="degree(O::Hecke.NfMaximalOrder) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/NfMaximalOrder.jl:89"></a>

---

```
degree(O::NfMaximalOrder) -> Int
```

> Returns the degree of $\mathcal O$, which is just the rank of $\mathcal O$ as a $\mathbb{Z}$-module or equivalently the degree of the ambient number field.


<a name="basis(O::Hecke.NfMaximalOrder) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/NfMaximalOrder.jl:122"></a>

---

```
basis(O::NfMaximalOrder) -> Array{NfOrderElem, 1}
```

> Returns the basis of $\mathcal O$.


<a name="basis(O::Hecke.NfMaximalOrder, K::Nemo.AnticNumberField) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/NfMaximalOrder.jl:133"></a>

---

```
basis(O::NfMaximalOrder, K::AnticNumberField -> Array{nf_elem, 1}
```

> Returns the basis of $\mathcal O$ as elements of $K$. The number field $K$ must be the ambient number field of $\mathcal O$.


<a name="basis_mat(O::Hecke.NfMaximalOrder) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/NfMaximalOrder.jl:98"></a>

---

```
basis_mat(O::NfMaximalOrder) -> FakeFmpqMat
```

> Returns the basis matrix of $\mathcal O$.


<a name="basis_mat_inv(O::Hecke.NfMaximalOrder) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/NfMaximalOrder.jl:107"></a>

```
basis_mat_inv(O::NfMaximalOrder) -> FakeFmpqMat
```

> Returns the inverse of the basis matrix of $\mathcal O$.


<a name="index(O::Hecke.NfMaximalOrder) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/NfMaximalOrder.jl:150"></a>

---

```
index(O::NfMaximalOrder) -> fmpz
```

> Returns the index $[ \mathcal{O} : \mathbf{Z}[\alpha]]$ of the equation order in the given maximal order $\mathcal O$. Here $\alpha$ is the primitive element of the ambient number field.


<a name="signature(O::Hecke.NfMaximalOrder) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/NfMaximalOrder.jl:198"></a>

---

```
signature(O::NfMaximalOrder) -> Tuple{Int, Int}
```

> Returns the signature of the ambient number field of $\mathcal O$.


<a name="is_index_divisor(O::Hecke.NfMaximalOrder, d::Union{Int64,Nemo.fmpz}) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/NfMaximalOrder.jl:187"></a>

---

```
is_index_divisor(O::NfMaximalOrder, d::Union{fmpz, Int})
```

> Returns whether $d$ is a divisor of $\operatorname{disc}(\mathcal O)$.


## Elements

<a name="call(O::Hecke.GenNfOrd, a::Nemo.nf_elem, check::Bool) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/GenNfOrd.jl:102"></a>

---

```
call(O::GenNfOrd, a::nf_elem, check::Bool = true) -> NfOrderElem
```

> Given an element $a$ of the ambient number field of $\mathcal O$, this function coerces the element into $\mathcal O$. It will be checked that $a$ is contained in $\mathcal O$ if and only if `check` is `true`.


<a name="call(O::Hecke.GenNfOrd, a::Union{Integer,Nemo.fmpz}) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/GenNfOrd.jl:120"></a>

---

```
call(O::GenNfOrd, a::Union{fmpz, Integer}) -> NfOrderElem
```

> Given an element $a$ of type `fmpz` or `Integer`, this function coerces the element into $\mathcal O$. It will be checked that $a$ is contained in $\mathcal O$ if and only if `check` is `true`.


<a name="call(O::Hecke.GenNfOrd, arr::Array{Nemo.fmpz,1}) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/GenNfOrd.jl:130"></a>

---

```
call(O::GenNfOrd, arr::Array{fmpz, 1})
```

> Returns the element of $\mathcal O$ with coefficient vector `arr`.


<a name="call{T<:Integer}(O::Hecke.GenNfOrd, arr::Array{T<:Integer,1}) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/GenNfOrd.jl:140"></a>

---

```
call{T <: Integer}(O::GenNfOrd, arr::Array{T, 1})
```

> Returns the element of $\mathcal O$ with coefficient vector `arr`.


<a name="call(O::Hecke.GenNfOrd, a::Nemo.nf_elem, arr::Array{Nemo.fmpz,1}) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/GenNfOrd.jl:152"></a>

```
call(x, args...)
```

If `x` is not a `Function`, then `x(args...)` is equivalent to `call(x, args...)`. This means that function-like behavior can be added to any type by defining new `call` methods.

---

```
call(O::GenNfOrd, a::nf_elem, arr::Array{fmpz, 1}) -> NfOrderElem
```

> This function constructs the element of $\mathcal O$ with coefficient vector `arr`. It is assumed that the corresponding element of the ambient number field is $a$.


---

```
call{T <: Integer}(O::GenNfOrd, arr::Array{T, 1})
```

> Returns the element of $\mathcal O$ with coefficient vector `arr`.


---

```
call(O::GenNfOrd, arr::Array{fmpz, 1})
```

> Returns the element of $\mathcal O$ with coefficient vector `arr`.


---

```
call(O::GenNfOrd, a::Union{fmpz, Integer}) -> NfOrderElem
```

> Given an element $a$ of type `fmpz` or `Integer`, this function coerces the element into $\mathcal O$. It will be checked that $a$ is contained in $\mathcal O$ if and only if `check` is `true`.


---

```
call(O::GenNfOrd, a::nf_elem, check::Bool = true) -> NfOrderElem
```

> Given an element $a$ of the ambient number field of $\mathcal O$, this function coerces the element into $\mathcal O$. It will be checked that $a$ is contained in $\mathcal O$ if and only if `check` is `true`.


---

```
call(O::GenNfOrd) -> NfOrderElem
```

> This function constructs a new element of $\mathcal O$ which is set to $0$.


<a name="call(O::Hecke.GenNfOrd) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/GenNfOrd.jl:162"></a>

---

```
call(O::GenNfOrd) -> NfOrderElem
```

> This function constructs a new element of $\mathcal O$ which is set to $0$.


<a name="parent(a::Hecke.NfOrderElem) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/GenNfOrd.jl:177"></a>

---

```
parent(a::NfOrderElem) -> GenNfOrd
```

> Returns the order of which $a$ is an element.


<a name="elem_in_nf(a::Hecke.NfOrderElem) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/GenNfOrd.jl:186"></a>

---

```
elem_in_nf(a::NfOrderElem) -> nf_elem
```

> Returns the element $a$ considered as an element of the ambient number field.


<a name="elem_in_basis(a::Hecke.NfOrderElem) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/GenNfOrd.jl:199"></a>

---

```
elem_in_basis(a::NfOrderElem) -> Array{fmpz, 1}
```

> Returns the coefficient vector of $a$.


<a name="==(x, y) at operators.jl:11"></a>

```
==(x, y)
```

Generic equality operator, giving a single `Bool` result. Falls back to `===`. Should be implemented for all types with a notion of equality, based on the abstract value that an instance represents. For example, all numeric types are compared by numeric value, ignoring type. Strings are compared as sequences of characters, ignoring encoding.

Follows IEEE semantics for floating-point numbers.

Collections should generally implement `==` by calling `==` recursively on all contents.

New numeric types should implement this function for two arguments of the new type, and handle comparison to other types via promotion rules where possible.

---

```
==(x::NfOrderElem, y::NfOrderElem) -> Bool
```

> Returns whether $x$ and $y$ are equal.


<a name="deepcopy(x::Hecke.NfOrderElem) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/GenNfOrd.jl:249"></a>

---

```
deepcopy(x::NfOrderElem) -> NfOrderElem
```

> Returns a copy of $x$.


<a name="in(a::Nemo.nf_elem, O::Hecke.GenNfOrd) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/GenNfOrd.jl:286"></a>

---

```
in(a::nf_elem, O::GenNfOrd) -> Bool
```

> Checks wether $a$ lies in $\mathcal O$.


<a name="den(a::Nemo.nf_elem, O::Hecke.GenNfOrd) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/GenNfOrd.jl:303"></a>

---

```
den(a::nf_elem, O::GenNfOrd) -> fmpz
```

> Returns the smallest positive integer k such that k*a lies in O.


<a name="zero(O::Hecke.GenNfOrd) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/GenNfOrd.jl:324"></a>

---

```
zero(O::GenNford) -> NfOrderElem
```

> returns an element of $\mathcal o$ which is set to zero.


<a name="one(O::Hecke.GenNfOrd) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/GenNfOrd.jl:332"></a>

---

```
one(O::GenNfOrd) -> NfOrderElem
```

> returns an element of $\mathcal o$ which is set to one.


<a name="-(x::Hecke.NfOrderElem) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/GenNfOrd.jl:357"></a>

---

```
-(x::NfOrderElem) -> NfOrderElem
```

> Returns the additive inverse of $x$.


```
-(x)
```

Unary minus operator.

<a name="*(x::Hecke.NfOrderElem, y::Hecke.NfOrderElem) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/GenNfOrd.jl:375"></a>

---

```
*(x::nforderelem, y::nforderelem) -> nforderelem
```

> returns $x \cdot y$.


```
*(x, y...)
```

Multiplication operator. `x*y*z*...` calls this function with all arguments, i.e. `*(x, y, z, ...)`.

<a name="+(x::Hecke.NfOrderElem, y::Hecke.NfOrderElem) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/GenNfOrd.jl:387"></a>

---

```
+(x::nforderelem, y::nforderelem) -> nforderelem
```

> returns $x + y$.


<a name="-(x::Hecke.NfOrderElem, y::Hecke.NfOrderElem) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/GenNfOrd.jl:399"></a>

---

```
-(x::nforderelem, y::nforderelem) -> nforderelem
```

> returns $x - y$.


```
-(x, y)
```

Subtraction operator.

<a name="*(x::Hecke.NfOrderElem, y::Union{Integer,Nemo.fmpz}) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/GenNfOrd.jl:417"></a>

---

```
*(x::NfOrderElem, y::Union{fmpz, Integer})
```

> Returns $x \cdot y$.


```
*(x, y...)
```

Multiplication operator. `x*y*z*...` calls this function with all arguments, i.e. `*(x, y, z, ...)`.

<a name="+(x::Hecke.NfOrderElem, y::Union{Integer,Nemo.fmpz}) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/GenNfOrd.jl:431"></a>

---

```
+(x::NfOrderElem, y::Union{fmpz, Integer})
```

> Returns $x + y$.


<a name="-(x::Hecke.NfOrderElem, y::Union{Integer,Nemo.fmpz}) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/GenNfOrd.jl:445"></a>

---

```
-(x::NfOrderElem, y::Union{fmpz, Integer})
```

> Returns $x - y$.


```
-(x, y)
```

Subtraction operator.

<a name="^(x::Hecke.NfOrderElem, y::Union{Int64,Nemo.fmpz}) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/GenNfOrd.jl:465"></a>

---

```
^(x::NfOrderElem, y::Union{fmpz, Int})
```

> Returns $x^y$.


```
^(x, y)
```

Exponentiation operator.

<a name="mod(a::Hecke.NfOrderElem, m::Union{Int64,Nemo.fmpz}) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/GenNfOrd.jl:484"></a>

---

```
mod(a::NfOrderElem, m::Union{fmpz, Int}) -> NfOrderElem
```

> Reduces the coefficient vector of $a$ modulo $m$ and returns the corresponding element.


<a name="powermod(a::Hecke.NfOrderElem, i::Integer, m::Nemo.fmpz) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/GenNfOrd.jl:545"></a>

---

```
powermod(a::NfOrderElem, i::Integer, m::fmpz) -> NfOrderElem
```

> Returns the element $a^i$ modulo $m$.


<a name="representation_mat(a::Hecke.NfOrderElem) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/GenNfOrd.jl:560"></a>

---

```
representation_mat(a::NfOrderElem) -> fmpz_mat
```

> Returns the representation matrix of the element $a$.


<a name="representation_mat(a::Hecke.NfOrderElem, K::Nemo.AnticNumberField) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/GenNfOrd.jl:575"></a>

```
representation_mat(a::NfOrderElem, K::AnticNumberField) -> FakeFmpqMat
```

> Returns the representation matrix of the element $a$ considered as an element of the ambient number field $K$. It is assumed that $K$ is the ambient number field of the order of $a$.


<a name="trace(a::Hecke.NfOrderElem) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/GenNfOrd.jl:597"></a>

---

```
trace(a::NfOrderElem) -> fmpz
```

> Returns the trace of $a$.


<a name="norm(a::Hecke.NfOrderElem) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/GenNfOrd.jl:613"></a>

---

```
norm(a::NfOrderElem) -> fmpz
```

> Returns the norm of $a$.


<a name="rand{T<:Union{Integer,Nemo.fmpz}}(O::Hecke.GenNfOrd, R::UnitRange{T<:Union{Integer,Nemo.fmpz}}) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/GenNfOrd.jl:642"></a>

---

```
rand{T <: Union{Integer, fmpz}}(z::NfOrderElem, O::GenNfOrd, R::UnitRange{T}) -> NfOrderElem
```

> Computes a coefficient vector with entries uniformly distributed in `R` and returns the corresponding element of the order.


<a name="rand(O::Hecke.GenNfOrd, n::Integer) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/GenNfOrd.jl:659"></a>

---

```
rand(z::NfOrderElem, O::GenNfOrd, n::Union{Integer, fmpz}) -> NfOrderElem
```

> Computes a coefficient vector with entries uniformly distributed in $\{-n,\dotsc,-1,0,1,\dotsc,n\}$ and returns the corresponding element of the order.


## Ideals

<a name="nf(x::Hecke.NfMaximalOrderIdeal) at /home/thofmann/.julia/v0.4/Hecke/src/NfMaximalOrder/Ideal.jl:130"></a>

```
nf(I::NfMaximalOrderIdeal) -> AnticNumberField
```

###### Description

Returns the number field, of which `I` is an integral ideal.

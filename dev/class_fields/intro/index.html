<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Hecke">
    <meta name="author" content="Tommy Hofmann">
    
    <link rel="../../img/favicon.ico">

    
    <title>Introduction - Hecke</title>
    

    <link rel="stylesheet" href="//use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU" crossorigin="anonymous">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.min.css">
    <link href='//fonts.googleapis.com/css?family=PT+Sans:400,400italic,700,700italic&subset=latin-ext,latin' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,700italic,400,300,600,700&subset=latin-ext,latin' rel='stylesheet' type='text/css'>
    <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
    <link href="../../css/base.min.css" rel="stylesheet">
    <link href="../../css/cinder.min.css" rel="stylesheet">
    <link href="../../css/highlight.min.css" rel="stylesheet">
    <link href="../../assets/Documenter.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
            <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
            <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
        <![endif]-->

    <script src="//ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js"></script>
    <script>
    WebFont.load({
        google: {
            families: ['Open Sans', 'PT Sans']
        }
    });
    </script>

    

     
</head>

<body>

    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->

            <a class="navbar-brand" href="../..">Hecke</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="../..">Home</a>
                    </li>
                
                
                
                    <li >
                        <a href="../../number_fields/intro/">Number fields</a>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Orders <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../../orders/introduction/">Introduction</a>
</li>

                        
                            
<li >
    <a href="../../orders/orders/">Basics</a>
</li>

                        
                            
<li >
    <a href="../../orders/elements/">Elements</a>
</li>

                        
                            
<li >
    <a href="../../orders/ideals/">Ideals</a>
</li>

                        
                            
<li >
    <a href="../../orders/frac_ideals/">Fractional Ideals</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Abelian groups <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../../abelian/introduction/">Introduction</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li class="dropdown active">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Class fields <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li class="active">
    <a href="./">Introduction</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Misc <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../../FacElem/">Factored Elements</a>
</li>

                        
                            
<li >
    <a href="../../sparse/intro/">Sparse Linear Algebra</a>
</li>

                        
                        </ul>
                    </li>
                
                
                </ul>

            <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                            <i class="fas fa-search"></i> Search
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../../abelian/introduction/">
                            <i class="fas fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="next" href="../../FacElem/">
                            Next <i class="fas fa-arrow-right"></i>
                        </a>
                    </li>
                    <li>
                        <a href="https://github.com/thofma/Hecke.jl/edit/master/docs/class_fields/intro.md">Edit on Hecke.jl</a>
                    </li>
            </ul>
        </div>
    </div>
</div>

    <div class="container">
        
        
        <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="first-level active"><a href="#class-field-theory">Class Field Theory</a></li>
            <li class="second-level"><a href="#introduction">Introduction</a></li>
                
            <li class="second-level"><a href="#ray-class-groups">Ray Class Groups</a></li>
                
            <li class="second-level"><a href="#ray-class-fields">Ray Class Fields</a></li>
                
                <li class="third-level"><a href="#example">Example</a></li>
            <li class="second-level"><a href="#conversions">Conversions</a></li>
                
            <li class="second-level"><a href="#invariants">Invariants</a></li>
                
            <li class="second-level"><a href="#operations">Operations</a></li>
                
    </ul>
</div></div>
        <div class="col-md-9" role="main">

<p><a id='Class-Field-Theory-1'></a></p>
<h1 id="class-field-theory">Class Field Theory</h1>
<p><a id='Introduction-1'></a></p>
<h2 id="introduction">Introduction</h2>
<p>This chapter deals with abelian extensions of number fields and the rational numbers.</p>
<p>Class Field Theory, here specifically, class field theory of global number fields, deals with abelian extension, ie. fields where the group of automorphisms is abelian. For extensions of {\Q}, the famous Kronnecker-Weber theorem classifies all such fields: a field is abelian if and only if it is contained in some cyclotomic field. For general number fields this is more involved and even for extensions of {\Q} is is not practical.</p>
<p>In Hecke, abelian extensions are parametrized by quotients of so called ray class groups. The language of ray class groups while dated is more applicable to algorithms than the modern language of idel class groups and quotients.</p>
<p><a id='Ray-Class-Groups-1'></a></p>
<h2 id="ray-class-groups">Ray Class Groups</h2>
<p>Given an integral ideal <script type="math/tex">m_0 \le Z_K</script> and a list of real places <script type="math/tex">m_\infty</script>, the ray class group modulo <script type="math/tex">(m_0, m_\infty)</script>, <script type="math/tex">C(m)</script> is defined as the group of ideals coprime to <script type="math/tex">m_0</script> modulo the elements <script type="math/tex">a\in K^*</script> s.th. <script type="math/tex">v_p(a-1) \ge v_p(m_0)</script> and for all <script type="math/tex">v\in m_\infty</script>, <script type="math/tex">a^{(v)} >0</script>. This is a finite abelian group. For <script type="math/tex">m_0 = Z_K</script> and <script type="math/tex">m_\infty = \{\}</script> we get <script type="math/tex">C()</script> is the class group, if <script type="math/tex">m_\infty</script> contains all real places, we obtain the narrow class group, or strict class group.</p>
<p><a id='Hecke.ray_class_group-Tuple{NfAbsOrdIdl{AnticNumberField,nf_elem},Array{InfPlc,1}}' href='#Hecke.ray_class_group-Tuple{NfAbsOrdIdl{AnticNumberField,nf_elem},Array{InfPlc,1}}'>#</a>
<strong><code>Hecke.ray_class_group</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">ray_class_group(m::NfOrdIdl, inf_plc::Array{InfPlc,1}=InfPlc[]; n_quo)
</code></pre>

<p>Given a modulus with finite part <script type="math/tex">m</script> and infinite part <script type="math/tex">inf_plc</script>, it returns the Ray Class Group <script type="math/tex">Cl_m</script>. If <script type="math/tex">n_quo</script> is given,  it will return the quotient of the Ray Class Group by n</p>
<div class="admonition warning">
<p class="admonition-title">Missing docstring.</p>
<p>Missing docstring for <code>class_group(O::Hecke.NfAbsOrd{Nemo.AnticNumberField,Nemo.nf_elem}; bound, method, redo, unit_method, large)</code>. Check Documenter's build log for details.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Missing docstring.</p>
<p>Missing docstring for <code>class_group(K::Nemo.AnticNumberField)</code>. Check Documenter's build log for details.</p>
</div>
<p><a id='Hecke.norm_group-Tuple{PolyElem,Hecke.MapRayClassGrp,Bool}' href='#Hecke.norm_group-Tuple{PolyElem,Hecke.MapRayClassGrp,Bool}'>#</a>
<strong><code>Hecke.norm_group</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">norm_group(f::Nemo.PolyElem, mR::Hecke.MapRayClassGrp, isabelian::Bool = true; of_closure::Bool = false) -&gt; Hecke.FinGenGrpAb, Hecke.FinGenGrpAbMap

norm_group(f::Array{PolyElem{nf_elem}, mR::Hecke.MapRayClassGrp, isabelian::Bool = true; of_closure::Bool = false) -&gt; Hecke.FinGenGrpAb, Hecke.FinGenGrpAbMap
</code></pre>

<p>Computes the subgroup of the Ray Class Group <script type="math/tex">R</script> given by the norm of the extension generated by a/the roots of <script type="math/tex">f</script>. If {{{isabelian}}} is set to true, then the code assumes the field to be abelian, hence the algorithm stops when the quotient by the norm group has the correct order. Even though the algorithm is probabilistic by nature, in this case the result is guaranteed. If {{{of_closure}}} is given, then the norm group of the splitting field of the polynomial(s) is computed. It is the callers responsibility to ensure that the ray class group passed in is large enough.</p>
<p><a id='Hecke.norm_group-Tuple{Hecke.NfRel{nf_elem},Hecke.MapRayClassGrp,Bool}' href='#Hecke.norm_group-Tuple{Hecke.NfRel{nf_elem},Hecke.MapRayClassGrp,Bool}'>#</a>
<strong><code>Hecke.norm_group</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">norm_group(K::NfRel{nf_elem}, mR::Hecke.MapRayClassGrp) -&gt; Hecke.FinGenGrpAb, Hecke.FinGenGrpAbMap

norm_group(K::NfRel_ns{nf_elem}, mR::Hecke.MapRayClassGrp) -&gt; Hecke.FinGenGrpAb, Hecke.FinGenGrpAbMap
</code></pre>

<p>Computes the subgroup of the Ray Class Group <script type="math/tex">R</script> given by the norm of the extension.</p>
<p><a id='Ray-Class-Fields-1'></a></p>
<h2 id="ray-class-fields">Ray Class Fields</h2>
<p>In general, the construction of a class field starts with a (ray) class group. Each quotient of a ray class group then defines a ray class field, the defining property is that the (relative) automorphism group is canonically isomorphic to the quotient of the ray class group where the isomorphism is given by the Artin (or Frobenius) map. Since, in Hecke, the (ray) class groups have no link to the field, actually this has to be specified using the maps.</p>
<p>It should be noted that this is a {\em lazy} construction: nothing is computed at this point.</p>
<p><a id='Hecke.ray_class_field-Tuple{Union{MapClassGrp, MapRayClassGrp}}' href='#Hecke.ray_class_field-Tuple{Union{MapClassGrp, MapRayClassGrp}}'>#</a>
<strong><code>Hecke.ray_class_field</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">ray_class_field(m::MapClassGrp) -&gt; ClassField
ray_class_field(m::MapRayClassGrp) -&gt; ClassField
</code></pre>

<p>Creates the (formal) abelian extension defined by the map <script type="math/tex">m: A \to I</script> where <script type="math/tex">I</script> is the set of ideals coprime to the modulus defining <script type="math/tex">m</script> and <script type="math/tex">A</script>  is a quotient of the ray class group (or class group). The map <script type="math/tex">m</script> must be the map returned from a call to {class<em>group} or {ray</em>class_group}.</p>
<p><a id='Hecke.ray_class_field-Tuple{Union{MapClassGrp, MapRayClassGrp},GrpAbFinGenMap}' href='#Hecke.ray_class_field-Tuple{Union{MapClassGrp, MapRayClassGrp},GrpAbFinGenMap}'>#</a>
<strong><code>Hecke.ray_class_field</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">ray_class_field(m::Union{MapClassGrp, MapRayClassGrp}, quomap::GrpAbFinGenMap) -&gt; ClassField
</code></pre>

<p>For <script type="math/tex">m</script> a map computed by either {ray<em>class</em>group} or {class_group} and <script type="math/tex">q</script> a canonical projection (quotient map) as returned by {quo} for q  quotient of the domain of <script type="math/tex">m</script> and a subgroup of <script type="math/tex">m</script>, create the (formal) abelian extension where the (relative) automorphism group is canonically isomorphic to the codomain of <script type="math/tex">q</script>.</p>
<p><a id='Hecke.ray_class_field-Tuple{NfAbsOrdIdl}' href='#Hecke.ray_class_field-Tuple{NfAbsOrdIdl}'>#</a>
<strong><code>Hecke.ray_class_field</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">ray_class_field(I::NfAbsOrdIdl; n_quo = 0) -&gt; ClassField
</code></pre>

<p>The ray class field modulo <script type="math/tex">I</script>. If {{{n_quo}}} is given, then the largest subfield of exponent <script type="math/tex">n</script> is computed.</p>
<p><a id='Hecke.ray_class_field-Tuple{NfAbsOrdIdl,Array{InfPlc,1}}' href='#Hecke.ray_class_field-Tuple{NfAbsOrdIdl,Array{InfPlc,1}}'>#</a>
<strong><code>Hecke.ray_class_field</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">ray_class_field(I::NfAbsOrdIdl, inf::Array{InfPlc, 1}; n_quo = 0) -&gt; ClassField
</code></pre>

<p>The ray class field modulo <script type="math/tex">I</script> and the infinite places given. If {{{n_quo}}} is given, then the largest subfield of exponent <script type="math/tex">n</script> is computed.</p>
<p><a id='Hecke.hilbert_class_field-Tuple{AnticNumberField}' href='#Hecke.hilbert_class_field-Tuple{AnticNumberField}'>#</a>
<strong><code>Hecke.hilbert_class_field</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">hilbert_class_field(k::AnticNumberField) -&gt; ClassField
</code></pre>

<p>The Hilbert class field of <script type="math/tex">k</script> as a formal (ray-) class field.</p>
<p><a id='Hecke.ring_class_field-Tuple{NfAbsOrd}' href='#Hecke.ring_class_field-Tuple{NfAbsOrd}'>#</a>
<strong><code>Hecke.ring_class_field</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">ring_class_field(O::NfAbsOrd) -&gt; ClassField
</code></pre>

<p>The ring class field of <script type="math/tex">O</script>, ie. the maximal abelian extension ramifed  only at primes dividing the conductor with the automorphism group isomorphic to the Picard group.</p>
<p><a id='Example-1'></a></p>
<h3 id="example">Example</h3>
<pre><code class="julia-repl">
julia&gt; Qx, x = PolynomialRing(FlintQQ, &quot;x&quot;);

julia&gt; K, a = NumberField(x^2 - 10, &quot;a&quot;);

julia&gt; c, mc = class_group(K)
(GrpAb: Z/2, ClassGroup map of
Set of ideals of Maximal order of Number field over Rational Field with defining polynomial x^2-10
with basis nf_elem[1, a]
)

julia&gt; A = ray_class_field(mc)
Class field defined mod (&lt;1, 1&gt;, InfPlc[]) of structure Abelian group with structure: Z/2
</code></pre>

<p><a id='Conversions-1'></a></p>
<h2 id="conversions">Conversions</h2>
<p>Given a ray class field, it is possible to actually compute defining equation(s) for this field. In general, the number field constructed this way will be non-simple by type and is defined by a polynomial for each maximal cyclic quotient of prime power order in the defining group.</p>
<p>The algorithm employed is based on Kummer-theory and requires the addition of a suitable root of unity. Progress can be monitored by setting {{{set<em>verbose</em>level(:ClassField, n)}}} where <script type="math/tex">0\le n\le 3</script>
</p>
<p><a id='Hecke.number_field-Tuple{Hecke.ClassField}' href='#Hecke.number_field-Tuple{Hecke.ClassField}'>#</a>
<strong><code>Hecke.number_field</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">NumberField(f::Generic.Poly{T}, s::String; cached::Bool = false, check::Bool = false) where T
</code></pre>

<p>Given an irreducible polynomial <script type="math/tex">f</script> over some number field <script type="math/tex">K</script>, create the field <script type="math/tex">K[t]/f</script>. <script type="math/tex">f</script> must be irreducible - although this is not tested.</p>
<pre><code>NumberField(f::Generic.Poly{T}; cached::Bool = false, check::Bool = false) where T
</code></pre>

<p>Given an irreducible polynomial <script type="math/tex">f</script> over some number field <script type="math/tex">K</script>, create the field <script type="math/tex">K[t]/f</script>. <script type="math/tex">f</script> must be irreducible - although this is not tested.</p>
<pre><code class="julia">number_field(f::Array{Generic.Poly{T}, 1}, s::String=&quot;_\$&quot;) where T -&gt; NfRel_ns
</code></pre>

<p>Given polynomials <script type="math/tex">f = (f_1, \ldots, f_n)</script> over some number field <script type="math/tex">k</script>, construct <script type="math/tex">K = k[t_1, \ldots, t_n]/\langle f_1(t_1), \ldots, f_n(t_n)\rangle</script> The ideal in the quotient must be maximal - although this is not tested.</p>
<pre><code>NumberField(CF::ClassField) -&gt; Hecke.NfRel_ns{Nemo.nf_elem}
</code></pre>

<p>Given a (formal) abelian extension, compute the class field by finding defining polynomials for all prime power cyclic subfields. Note, by type this is always a non-simple extension.</p>
<pre><code class="julia-repl">
julia&gt; Qx, x = PolynomialRing(FlintQQ, &quot;x&quot;);

julia&gt; k, a = NumberField(x^2 - 10, &quot;a&quot;);

julia&gt; c, mc = class_group(k);

julia&gt; A = ray_class_field(mc)
Class field defined mod (&lt;1, 1&gt;, InfPlc[]) of structure Abelian group with structure: Z/2

julia&gt; K = number_field(A)
non-simple Relative number field over
Number field over Rational Field with defining polynomial x^2-10
 with defining polynomials AbstractAlgebra.Generic.MPoly{nf_elem}[_$1^2+(-2)]

julia&gt; ZK = maximal_order(K)
Relative maximal order of non-simple Relative number field over
Number field over Rational Field with defining polynomial x^2-10
 with defining polynomials AbstractAlgebra.Generic.MPoly{nf_elem}[_$1^2+(-2)]
with pseudo-basis
(1, 1//1 * &lt;1, a+1&gt;)
(_$1+(a), 1//4 * &lt;2, 3*a&gt;)

julia&gt; isone(discriminant(ZK))
true
</code></pre>

<p><a id='Hecke.ray_class_field-Tuple{Hecke.NfRel{nf_elem}}' href='#Hecke.ray_class_field-Tuple{Hecke.NfRel{nf_elem}}'>#</a>
<strong><code>Hecke.ray_class_field</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">ray_class_field(K::NfRel{nf_elem}) -&gt; ClassField
</code></pre>

<p>For a (relative) abelian extension, compute an abstract representation as a class field. </p>
<p><a id='Hecke.genus_field-Tuple{Hecke.ClassField,AnticNumberField}' href='#Hecke.genus_field-Tuple{Hecke.ClassField,AnticNumberField}'>#</a>
<strong><code>Hecke.genus_field</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">genus_field(A::ClassField, k::AnticNumberField) -&gt; ClassField
</code></pre>

<p>The maximal extension contained in <script type="math/tex">A</script> that is the compositum of <script type="math/tex">K</script> with an abelian extension of <script type="math/tex">k</script>.</p>
<p><a id='Hecke.maximal_abelian_subfield-Tuple{Hecke.ClassField,AnticNumberField}' href='#Hecke.maximal_abelian_subfield-Tuple{Hecke.ClassField,AnticNumberField}'>#</a>
<strong><code>Hecke.maximal_abelian_subfield</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">maximal_abelian_subfield(A::ClassField, k::AnticNumberField) -&gt; ClassField
</code></pre>

<p>The maximal abelian extension of <script type="math/tex">k</script> contained in <script type="math/tex">A</script>. <script type="math/tex">k</script> must be a subfield of the base field of <script type="math/tex">A</script>.</p>
<p><a id='Hecke.maximal_abelian_subfield-Tuple{Hecke.NfRel{nf_elem}}' href='#Hecke.maximal_abelian_subfield-Tuple{Hecke.NfRel{nf_elem}}'>#</a>
<strong><code>Hecke.maximal_abelian_subfield</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">maximal_abelian_subfield(K::NfRel{nf_elem}; of_closure::Bool = false) -&gt; ClassField
</code></pre>

<p>Using a probabilistic algorithm for the norm group computation, determine tha maximal abelian subfield in <script type="math/tex">K</script> over its base field. If {{{of_closure}}} is set to true, then the algorithm is applied to the normal closure if <script type="math/tex">K</script> (without computing it).</p>
<p><a id='Invariants-1'></a></p>
<h2 id="invariants">Invariants</h2>
<p><a id='AbstractAlgebra.Generic.degree-Tuple{Hecke.ClassField}' href='#AbstractAlgebra.Generic.degree-Tuple{Hecke.ClassField}'>#</a>
<strong><code>AbstractAlgebra.Generic.degree</code></strong> &mdash; <em>Method</em>.</p>
<p>degree(A::ClassField) The degree of <script type="math/tex">A</script> over its base field, ie. the size of the defining ideal group.</p>
<p><a id='AbstractAlgebra.Generic.base_ring-Tuple{Hecke.ClassField}' href='#AbstractAlgebra.Generic.base_ring-Tuple{Hecke.ClassField}'>#</a>
<strong><code>AbstractAlgebra.Generic.base_ring</code></strong> &mdash; <em>Method</em>.</p>
<p>base_ring(A::ClassField) The maximal order of the field that <script type="math/tex">A</script> is defined over.</p>
<p><a id='Hecke.base_field-Tuple{Hecke.ClassField}' href='#Hecke.base_field-Tuple{Hecke.ClassField}'>#</a>
<strong><code>Hecke.base_field</code></strong> &mdash; <em>Method</em>.</p>
<p>base_field(A::ClassField) The number field that <script type="math/tex">A</script> is defined over.</p>
<p><a id='AbstractAlgebra.Generic.discriminant-Tuple{Hecke.ClassField}' href='#AbstractAlgebra.Generic.discriminant-Tuple{Hecke.ClassField}'>#</a>
<strong><code>AbstractAlgebra.Generic.discriminant</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">discriminant(C::ClassField) -&gt; NfOrdIdl
</code></pre>

<p>Using the conductor-discriminant formula, compute the (relative) discriminant of <script type="math/tex">C</script>. This does not use the defining equations.</p>
<p><a id='Hecke.conductor-Tuple{Hecke.ClassField}' href='#Hecke.conductor-Tuple{Hecke.ClassField}'>#</a>
<strong><code>Hecke.conductor</code></strong> &mdash; <em>Method</em>.</p>
<p>conductor(C::Hecke.ClassField) -&gt; NfOrdIdl, Array{InfPlc,1}</p>
<p>Return the conductor of the abelian extension corresponding to C</p>
<p><a id='Hecke.defining_modulus-Tuple{Hecke.ClassField}' href='#Hecke.defining_modulus-Tuple{Hecke.ClassField}'>#</a>
<strong><code>Hecke.defining_modulus</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">defining_modulus(CF::ClassField)
</code></pre>

<p>The modulus, ie. an ideal the the set of real places, used to create the class field.</p>
<p><a id='Hecke.iscyclic-Tuple{Hecke.ClassField}' href='#Hecke.iscyclic-Tuple{Hecke.ClassField}'>#</a>
<strong><code>Hecke.iscyclic</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">iscyclic(C::ClassField)
</code></pre>

<p>Tests if the (relative) automorphism group of <script type="math/tex">C</script> is cyclic (by checking the defining ideal group).</p>
<p><a id='Hecke.isconductor-Tuple{Hecke.ClassField,NfAbsOrdIdl{AnticNumberField,nf_elem},Array{InfPlc,1}}' href='#Hecke.isconductor-Tuple{Hecke.ClassField,NfAbsOrdIdl{AnticNumberField,nf_elem},Array{InfPlc,1}}'>#</a>
<strong><code>Hecke.isconductor</code></strong> &mdash; <em>Method</em>.</p>
<p>isconductor(C::Hecke.ClassField, m::NfOrdIdl, inf_plc::Array{InfPlc,1}=InfPlc[]; check) -&gt; NfOrdIdl, Array{InfPlc,1}</p>
<p>Checks if m, inf_plc is the conductor of the abelian extension corresponding to C. If check is false, it assumes that the  given modulus is a multiple of the conductor. This is generically faster than computing the conductor.</p>
<p><a id='Hecke.isnormal-Tuple{Hecke.ClassField}' href='#Hecke.isnormal-Tuple{Hecke.ClassField}'>#</a>
<strong><code>Hecke.isnormal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">isnormal(C::ClassField) -&gt; Bool
</code></pre>

<p>For a class field <script type="math/tex">C</script> defined over a normal base field <script type="math/tex">k</script>, decide if <script type="math/tex">C</script> is normal over <script type="math/tex">Q</script>.</p>
<p><a id='Hecke.iscentral-Tuple{Hecke.ClassField}' href='#Hecke.iscentral-Tuple{Hecke.ClassField}'>#</a>
<strong><code>Hecke.iscentral</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">iscentral(C::ClassField) -&gt; Bool
</code></pre>

<p>For a class field <script type="math/tex">C</script> defined over a normal base field <script type="math/tex">k</script>, decide if <script type="math/tex">C</script> is central over <script type="math/tex">Q</script>.</p>
<p><a id='Operations-1'></a></p>
<h2 id="operations">Operations</h2>
<p><a id='Base.:*-Tuple{Hecke.ClassField,Hecke.ClassField}' href='#Base.:*-Tuple{Hecke.ClassField,Hecke.ClassField}'>#</a>
<strong><code>Base.:*</code></strong> &mdash; <em>Method</em>.</p>
<p>*(A::ClassField, B::ClassField) -&gt; ClassField The compositum of <script type="math/tex">a</script> and <script type="math/tex">b</script> as a (formal) class field.</p>
<p><a id='Hecke.compositum-Tuple{Hecke.ClassField,Hecke.ClassField}' href='#Hecke.compositum-Tuple{Hecke.ClassField,Hecke.ClassField}'>#</a>
<strong><code>Hecke.compositum</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">compositum(a::ClassField, b::ClassField) -&gt; ClassField
         *(a::ClassField, b::ClassField) -&gt; ClassField
</code></pre>

<p>The compositum of <script type="math/tex">a</script> and <script type="math/tex">b</script> as a (formal) class field.</p>
<p><a id='Base.:==-Tuple{Hecke.ClassField,Hecke.ClassField}' href='#Base.:==-Tuple{Hecke.ClassField,Hecke.ClassField}'>#</a>
<strong><code>Base.:==</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">==(a::ClassField, b::ClassField)
</code></pre>

<p>Tests if <script type="math/tex">a</script> and <script type="math/tex">b</script> are equal.</p>
<p><a id='Base.intersect-Tuple{Hecke.ClassField,Hecke.ClassField}' href='#Base.intersect-Tuple{Hecke.ClassField,Hecke.ClassField}'>#</a>
<strong><code>Base.intersect</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">intersect(a::ClassField, b::ClassField) -&gt; ClassField
</code></pre>

<p>The intersect of <script type="math/tex">a</script> and <script type="math/tex">b</script> as a class field.</p>
<p><a id='Hecke.prime_decomposition_type-Tuple{Hecke.ClassField,NfAbsOrdIdl}' href='#Hecke.prime_decomposition_type-Tuple{Hecke.ClassField,NfAbsOrdIdl}'>#</a>
<strong><code>Hecke.prime_decomposition_type</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">prime_decomposition_type(C::ClassField, p::NfAbsOrdIdl) -&gt; (Int, Int, Int)
</code></pre>

<p>For a prime <script type="math/tex">p</script> in the base ring of <script type="math/tex">r</script>, determine the splitting type of <script type="math/tex">p</script>  in <script type="math/tex">r</script>. ie. the tuple <script type="math/tex">(e, f, g)</script> giving the ramification degree, the inertia and the number of primes above <script type="math/tex">p</script>.</p>
<p><a id='Hecke.issubfield-Tuple{Hecke.ClassField,Hecke.ClassField}' href='#Hecke.issubfield-Tuple{Hecke.ClassField,Hecke.ClassField}'>#</a>
<strong><code>Hecke.issubfield</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">issubfield(a::ClassField, b::ClassField) -&gt; Bool
</code></pre>

<p>Determines of <script type="math/tex">a</script> is a subfield of <script type="math/tex">b</script>.</p>
<p><a id='Hecke.islocal_norm-Tuple{Hecke.ClassField,NfAbsOrdElem}' href='#Hecke.islocal_norm-Tuple{Hecke.ClassField,NfAbsOrdElem}'>#</a>
<strong><code>Hecke.islocal_norm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">islocal_norm(r::ClassField, a::NfAbsOrdElem) -&gt; Bool
</code></pre>

<p>Tests if <script type="math/tex">a</script> is a local norm at all finite places in the extension implictly given by <script type="math/tex">r</script>.</p>
<p><a id='Hecke.islocal_norm-Tuple{Hecke.ClassField,NfAbsOrdElem,NfAbsOrdIdl}' href='#Hecke.islocal_norm-Tuple{Hecke.ClassField,NfAbsOrdElem,NfAbsOrdIdl}'>#</a>
<strong><code>Hecke.islocal_norm</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">islocal_norm(r::ClassField, a::NfAbsOrdElem, p::NfAbsOrdIdl) -&gt; Bool
</code></pre>

<p>Tests if <script type="math/tex">a</script> is a local norm at <script type="math/tex">p</script> in the extension implictly given by <script type="math/tex">r</script>. Currently the conductor cannot have infinite places.</p>
<p><a id='Hecke.normal_closure-Tuple{Hecke.ClassField}' href='#Hecke.normal_closure-Tuple{Hecke.ClassField}'>#</a>
<strong><code>Hecke.normal_closure</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">normal_closure(C::ClassField) -&gt; ClassField
</code></pre>

<p>For a ray class field <script type="math/tex">C</script> extending a normal base field <script type="math/tex">k</script>, compute the normal closure over <script type="math/tex">Q</script>.</p>
<p><a id='Hecke.subfields-Tuple{Hecke.ClassField}' href='#Hecke.subfields-Tuple{Hecke.ClassField}'>#</a>
<strong><code>Hecke.subfields</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">subfields(C::ClassField) -&gt; Array{ClassField, 1}
</code></pre>

<p>Find all subfields of <script type="math/tex">C</script> as class fields.     Note: this will not find all subfields over <script type="math/tex">Q</script>, but only the ones sharing the same base field.</p>
<p><a id='Hecke.subfields-Tuple{Hecke.ClassField,Int64}' href='#Hecke.subfields-Tuple{Hecke.ClassField,Int64}'>#</a>
<strong><code>Hecke.subfields</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">subfields(C::ClassField, d::Int) -&gt; Array{ClassField, 1}
</code></pre>

<p>Find all subfields of <script type="math/tex">C</script> of degree <script type="math/tex">d</script> as class fields.     Note: this will not find all subfields over <script type="math/tex">Q</script>, but only the ones sharing the same base field.</p></div>
        
        
    </div>

    <footer class="col-md-12 text-center">
        
        <hr>
        <p>
        <small>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p></small>

        
        
    </footer>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script src="../../js/bootstrap-3.0.3.min.js"></script>
    <script src="../../js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script>var base_url = "../.."</script>
    
    <script src="../../js/base.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_HTML"></script>
    <script src="../../assets/mathjaxhelper.js"></script>
    <script src="../../search/main.js"></script>

    <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form>
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>
    </body>

</html>

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Hecke">
    <meta name="author" content="Tommy Hofmann">
    
    <link rel="../img/favicon.ico">

    
    <title>Factored Elements - Hecke</title>
    

    <link rel="stylesheet" href="//use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU" crossorigin="anonymous">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.min.css">
    <link href='//fonts.googleapis.com/css?family=PT+Sans:400,400italic,700,700italic&subset=latin-ext,latin' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,700italic,400,300,600,700&subset=latin-ext,latin' rel='stylesheet' type='text/css'>
    <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
    <link href="../css/base.min.css" rel="stylesheet">
    <link href="../css/cinder.min.css" rel="stylesheet">
    <link href="../css/highlight.min.css" rel="stylesheet">
    <link href="../assets/Documenter.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
            <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
            <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
        <![endif]-->

    <script src="//ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js"></script>
    <script>
    WebFont.load({
        google: {
            families: ['Open Sans', 'PT Sans']
        }
    });
    </script>

    

     
</head>

<body>

    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->

            <a class="navbar-brand" href="..">Hecke</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="..">Home</a>
                    </li>
                
                
                
                    <li >
                        <a href="../number_fields/intro/">Number fields</a>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Orders <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../orders/introduction/">Introduction</a>
</li>

                        
                            
<li >
    <a href="../orders/orders/">Basics</a>
</li>

                        
                            
<li >
    <a href="../orders/elements/">Elements</a>
</li>

                        
                            
<li >
    <a href="../orders/ideals/">Ideals</a>
</li>

                        
                            
<li >
    <a href="../orders/frac_ideals/">Fractional Ideals</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Abelian groups <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../abelian/introduction/">Introduction</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Class fields <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../class_fields/intro/">Introduction</a>
</li>

                        
                        </ul>
                    </li>
                
                
                
                    <li class="dropdown active">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Misc <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li class="active">
    <a href="./">Factored Elements</a>
</li>

                        
                            
<li >
    <a href="../sparse/intro/">Sparse Linear Algebra</a>
</li>

                        
                        </ul>
                    </li>
                
                
                </ul>

            <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                            <i class="fas fa-search"></i> Search
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../class_fields/intro/">
                            <i class="fas fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="next" href="../sparse/intro/">
                            Next <i class="fas fa-arrow-right"></i>
                        </a>
                    </li>
                    <li>
                        <a href="https://github.com/thofma/Hecke.jl/edit/master/docs/FacElem.md">Edit on Hecke.jl</a>
                    </li>
            </ul>
        </div>
    </div>
</div>

    <div class="container">
        
        
        <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="first-level active"><a href="#factored-elements">Factored Elements</a></li>
            <li class="second-level"><a href="#construction">Construction</a></li>
                
            <li class="second-level"><a href="#conversion">Conversion</a></li>
                
            <li class="second-level"><a href="#special-functions">Special functions</a></li>
                
            <li class="second-level"><a href="#miscellaneous">Miscellaneous</a></li>
                
    </ul>
</div></div>
        <div class="col-md-9" role="main">

<p><a id='Factored-Elements-1'></a></p>
<h1 id="factored-elements">Factored Elements</h1>
<p>In many applications in number theory related to the multiplicative structure of number fields, interesting elements, e.g. units, are extremely large when written wrt. to a fxied basis for the field: for the fundamental unit in <script type="math/tex">Q[\sqrt d]</script> it is known that the coefficients wrt. the canonical basis <script type="math/tex">1, \sqrt d</script> can have <script type="math/tex">O(\exp \sqrt d)</script> many digits. All currently known, fast methods construct those elements as power products of smaller elements, allowing the computer to handle them.</p>
<p>Mathematically, one can think of factored elements to formally live in the ring <script type="math/tex">Z[K]</script> the group ring of the non-zero field elements. Thus elements are of the form <script type="math/tex"> \prod a*i^{e*i}</script> where <script type="math/tex">a_i</script> are elements in <script type="math/tex">K</script>, typically <em>small</em> and the <script type="math/tex">e_i\in Z</script> are frequently  large exponents. We refer to the <script type="math/tex">a_i</script> as the <em>base</em> and the <script type="math/tex">e_i</script> as the  <em>exponents</em> of the factored element.</p>
<p>Since <script type="math/tex">K</script> is, in general, no PID, this presentation is non-unique, elements in this form can easily be multiplied, raised to large powers, but in general not compared and not added.</p>
<p>In Hecke, this is caputured more generally by the type <code>FacElem</code>,  parametrized by the type of the elements in the base and the type of their  parent.</p>
<p>Important special cases are</p>
<ul>
<li><code>FacElem{fmpz, FlintIntegerRing}</code>, factored integers</li>
<li><code>FacElem{nf_elem, AnticNumberField}</code>, factored algerbaic numbers</li>
<li><code>FacElem{NfAbsOrdIdl, NfAbsOrdIdlSet}</code>, factored ideals</li>
</ul>
<p>It should be noted that an object of type `<script type="math/tex">FacElem{fmpz, FlintIntegerRing}</script>  will, in general, not represent an integer as the exponents can be negative.</p>
<p><a id='Construction-1'></a></p>
<h2 id="construction">Construction</h2>
<p>In general one can define factored elements by giving 2 arrays, the  base and the exponent, or a dictionary containing the pairs:</p>
<p><a id='Hecke.FacElem' href='#Hecke.FacElem'>#</a>
<strong><code>Hecke.FacElem</code></strong> &mdash; <em>Type</em>.</p>
<pre><code class="julia">FacElem{B}(base::Array{B, 1}, exp::Array{fmpz, 1}) -&gt; FacElem{B}
</code></pre>

<p>Returns the element <script type="math/tex">\prod b_i^{e_i}</script>, un-expanded.</p>
<pre><code>FacElem{B}(d::Dict{B, fmpz}) -&gt; FacElem{B}
FacElem{B}(d::Dict{B, Integer}) -&gt; FacElem{B}
</code></pre>

<p>Returns the element <script type="math/tex">\prod b^{d[p]}</script>, un-expanded.</p>
<p><a id='Hecke.FacElem-Tuple{nf_elem}' href='#Hecke.FacElem-Tuple{nf_elem}'>#</a>
<strong><code>Hecke.FacElem</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">FacElem{B}(base::Array{B, 1}, exp::Array{fmpz, 1}) -&gt; FacElem{B}
</code></pre>

<p>Returns the element <script type="math/tex">\prod b_i^{e_i}</script>, un-expanded.</p>
<pre><code>FacElem{B}(d::Dict{B, fmpz}) -&gt; FacElem{B}
FacElem{B}(d::Dict{B, Integer}) -&gt; FacElem{B}
</code></pre>

<p>Returns the element <script type="math/tex">\prod b^{d[p]}</script>, un-expanded.</p>
<p><a id='Hecke.ideal-Tuple{NfAbsOrd{AnticNumberField,nf_elem},FacElem{nf_elem,AnticNumberField}}' href='#Hecke.ideal-Tuple{NfAbsOrd{AnticNumberField,nf_elem},FacElem{nf_elem,AnticNumberField}}'>#</a>
<strong><code>Hecke.ideal</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia"> ideal(O::NfOrd, a::FacElem{nf_elem, AnticNumberField)
</code></pre>

<p>The factored fractional ideal <script type="math/tex">a*O</script>.</p>
<p><a id='Conversion-1'></a></p>
<h2 id="conversion">Conversion</h2>
<p>The process of computing the value defined by a factored element is available as <code>evaluate</code>. Depending on the types involved this can be very efficient.</p>
<p><a id='AbstractAlgebra.Generic.evaluate-Union{Tuple{FacElem{fmpz,S}}, Tuple{S}} where S' href='#AbstractAlgebra.Generic.evaluate-Union{Tuple{FacElem{fmpz,S}}, Tuple{S}} where S'>#</a>
<strong><code>AbstractAlgebra.Generic.evaluate</code></strong> &mdash; <em>Method</em>.</p>
<p>evaluate{T}(x::FacElem{T}) -&gt; T</p>
<p>Expands or evaluates the factored element, i.e. actually computes the value.  Does "square-and-multiply" on the exponent vectors.</p>
<p><a id='AbstractAlgebra.Generic.evaluate-Tuple{FacElem{fmpq,S} where S}' href='#AbstractAlgebra.Generic.evaluate-Tuple{FacElem{fmpq,S} where S}'>#</a>
<strong><code>AbstractAlgebra.Generic.evaluate</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">evaluate(x::FacElem{fmpq}) -&gt; fmpq
evaluate(x::FacElem{fmpz}) -&gt; fmpz
</code></pre>

<p>Expands or evaluates the factored element, i.e. actually computes the the element.  Works by first obtaining a simplified version of the power product into coprime base elements.</p>
<p><a id='AbstractAlgebra.Generic.evaluate-Union{Tuple{FacElem{T,S} where S}, Tuple{T}} where T' href='#AbstractAlgebra.Generic.evaluate-Union{Tuple{FacElem{T,S} where S}, Tuple{T}} where T'>#</a>
<strong><code>AbstractAlgebra.Generic.evaluate</code></strong> &mdash; <em>Method</em>.</p>
<p>evaluate{T}(x::FacElem{T}) -&gt; T</p>
<p>Expands or evaluates the factored element, i.e. actually computes the value.  Does "square-and-multiply" on the exponent vectors.</p>
<p><a id='Hecke.evaluate_naive-Union{Tuple{FacElem{T,S} where S}, Tuple{T}} where T' href='#Hecke.evaluate_naive-Union{Tuple{FacElem{T,S} where S}, Tuple{T}} where T'>#</a>
<strong><code>Hecke.evaluate_naive</code></strong> &mdash; <em>Method</em>.</p>
<p>evaluate_naive{T}(x::FacElem{T}) -&gt; T</p>
<p>Expands or evaluates the factored element, i.e. actually computes the value. Uses the obvious naive algorithm. Faster for input in finite rings.</p>
<p><a id='Special-functions-1'></a></p>
<h2 id="special-functions">Special functions</h2>
<p>In the case where the parent of the base allows for efficient gcd computation, power products can be made unique:</p>
<p><a id='Hecke.simplify-Tuple{FacElem{NfAbsOrdIdl{AnticNumberField,nf_elem},Hecke.NfAbsOrdIdlSet{AnticNumberField,nf_elem}}}' href='#Hecke.simplify-Tuple{FacElem{NfAbsOrdIdl{AnticNumberField,nf_elem},Hecke.NfAbsOrdIdlSet{AnticNumberField,nf_elem}}}'>#</a>
<strong><code>Hecke.simplify</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">simplify(x::FacElem{NfOrdIdl, NfOrdIdlSet}) -&gt; FacElem
simplify(x::FacElem{NfOrdFracIdl, NfOrdFracIdlSet}) -&gt; FacElem
</code></pre>

<p>Uses <code>coprime_base</code> to obtain a simplified version of <script type="math/tex">x</script>, ie. in the simplified version all base ideals will be pariwise coprime but not neccessarily prime!.</p>
<p><a id='Hecke.simplify-Tuple{FacElem{fmpq,S} where S}' href='#Hecke.simplify-Tuple{FacElem{fmpq,S} where S}'>#</a>
<strong><code>Hecke.simplify</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">simplify(x::FacElem{fmpq}) -&gt; FacElem{fmpq}
simplify(x::FacElem{fmpz}) -&gt; FacElem{fmpz}
</code></pre>

<p>Simplfies the factored element, i.e. arranges for the base to be coprime.</p>
<p>The simplified version can then be used further:</p>
<p><a id='Base.isone-Tuple{FacElem{fmpq,S} where S}' href='#Base.isone-Tuple{FacElem{fmpq,S} where S}'>#</a>
<strong><code>Base.isone</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">isone(x::FacElem{fmpq}) -&gt; Bool
isone(x::FacElem{fmpz}) -&gt; Bool
</code></pre>

<p>Tests if <script type="math/tex">x</script> represents <script type="math/tex">1</script> without an evaluation.</p>
<p><a id='Hecke.factor_coprime-Tuple{FacElem{fmpz,S} where S}' href='#Hecke.factor_coprime-Tuple{FacElem{fmpz,S} where S}'>#</a>
<strong><code>Hecke.factor_coprime</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">factor_coprime(x::FacElem{fmpz}) -&gt; Fac{fmpz}
</code></pre>

<p>Computed a partial factorisation of <script type="math/tex">x</script>, ie. writes <script type="math/tex">x</script> as a product of pariwise coprime integers.</p>
<p><a id='Hecke.factor_coprime-Tuple{FacElem{NfAbsOrdIdl{AnticNumberField,nf_elem},Hecke.NfAbsOrdIdlSet{AnticNumberField,nf_elem}}}' href='#Hecke.factor_coprime-Tuple{FacElem{NfAbsOrdIdl{AnticNumberField,nf_elem},Hecke.NfAbsOrdIdlSet{AnticNumberField,nf_elem}}}'>#</a>
<strong><code>Hecke.factor_coprime</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">factor_coprime(x::FacElem{NfOrdIdl, NfOrdIdlSet}) -&gt; Dict{NfOrdIdl, Int}
</code></pre>

<p>Computed a partial factorisation of <script type="math/tex">x</script>, ie. writes <script type="math/tex">x</script> as a product of pariwise coprime integral ideals.</p>
<p><a id='Hecke.factor_coprime-Tuple{FacElem{Hecke.NfOrdFracIdl,Hecke.NfOrdFracIdlSet}}' href='#Hecke.factor_coprime-Tuple{FacElem{Hecke.NfOrdFracIdl,Hecke.NfOrdFracIdlSet}}'>#</a>
<strong><code>Hecke.factor_coprime</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia"> factor_coprime(Q::FacElem{NfOrdFracIdl, NfOrdFracIdlSet}) -&gt; Dict{NfOrdIdl, Int}
</code></pre>

<p>A coprime factorisation of <script type="math/tex">Q</script>: each ideal in <script type="math/tex">Q</script> is split using \code{integral_split} and then a coprime basis is computed. This does {\bf not} use any factorisation.</p>
<p><a id='Hecke.factor_coprime-Tuple{FacElem{nf_elem,AnticNumberField},Hecke.NfAbsOrdIdlSet{AnticNumberField,nf_elem}}' href='#Hecke.factor_coprime-Tuple{FacElem{nf_elem,AnticNumberField},Hecke.NfAbsOrdIdlSet{AnticNumberField,nf_elem}}'>#</a>
<strong><code>Hecke.factor_coprime</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">factor_coprime(a::FacElem{nf_elem, AnticNumberField}, I::NfOrdIdlSet) -&gt; Dict{NfOrdIdl, fmpz}
</code></pre>

<p>Factors the rincipal ideal generated by <script type="math/tex">a</script> into coprimes by computing a coprime basis from the principal ideals in the factorisation of <script type="math/tex">a</script>.</p>
<p><a id='Hecke.factor-Tuple{FacElem{Hecke.NfOrdFracIdl,Hecke.NfOrdFracIdlSet}}' href='#Hecke.factor-Tuple{FacElem{Hecke.NfOrdFracIdl,Hecke.NfOrdFracIdlSet}}'>#</a>
<strong><code>Hecke.factor</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia"> factor(Q::FacElem{NfOrdFracIdl, NfOrdFracIdlSet}) -&gt; Dict{NfOrdIdl, Int}
</code></pre>

<p>The factorisation of <script type="math/tex">Q</script>, by refining a coprime factorisation.</p>
<p><a id='Hecke.factor-Tuple{FacElem{nf_elem,AnticNumberField},Hecke.NfAbsOrdIdlSet{AnticNumberField,nf_elem}}' href='#Hecke.factor-Tuple{FacElem{nf_elem,AnticNumberField},Hecke.NfAbsOrdIdlSet{AnticNumberField,nf_elem}}'>#</a>
<strong><code>Hecke.factor</code></strong> &mdash; <em>Method</em>.</p>
<p>factor(a::FacElem{nf_elem, AnticNumberField}, I::NfOrdIdlSet) -&gt; Dict{NfOrdIdl, fmpz} Factors the principal ideal generated by <script type="math/tex">a</script> by refinind a coprime factorisation.</p>
<p>For factorised algebraic numbers a unique simplification is not possible, however, this allows still do obtain partial results:</p>
<p><a id='Hecke.compact_presentation' href='#Hecke.compact_presentation'>#</a>
<strong><code>Hecke.compact_presentation</code></strong> &mdash; <em>Function</em>.</p>
<pre><code class="julia">compact_presentation(a::FacElem{nf_elem, AnticNumberField}, n::Int = 2; decom, arb_prec = 100, short_prec = 1000) -&gt; FacElem
</code></pre>

<p>Computes a presentation <script type="math/tex">a = \prod a_i^{n_i}</script> where all the exponents <script type="math/tex">n_i</script> are powers of <script type="math/tex">n</script> and, the elements <script type="math/tex">a</script> are "small", generically, they have a norm bounded by <script type="math/tex">d^{n/2}</script> where <script type="math/tex">d</script> is the discriminant of the maximal order. As the algorithm needs the factorisation of the principal ideal generated by <script type="math/tex">a</script>, it can be passed in in \code{decom}.</p>
<p><a id='Hecke.signs-Tuple{Union{FacElem{nf_elem,AnticNumberField}, nf_elem}}' href='#Hecke.signs-Tuple{Union{FacElem{nf_elem,AnticNumberField}, nf_elem}}'>#</a>
<strong><code>Hecke.signs</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">signs(a::nf_elem)          -&gt; Dict{InfPlc, Int}
signs(a::FacElem{nf_elem}) -&gt; Dict{InfPlc, Int}
</code></pre>

<p>This function returns a dictionary of the signs of <script type="math/tex">a</script> at all infinite places of the ambient number field. The keys are infinite places of the ambient number field. The value is <script type="math/tex">1</script> if the sign is positive and <script type="math/tex">-1</script> if the sign is negative.</p>
<p><a id='Hecke.signs-Tuple{Union{FacElem{nf_elem,AnticNumberField}, nf_elem},Array{InfPlc,1}}' href='#Hecke.signs-Tuple{Union{FacElem{nf_elem,AnticNumberField}, nf_elem},Array{InfPlc,1}}'>#</a>
<strong><code>Hecke.signs</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">signs(a::nf_elem, l::Vector{InfPlc})          -&gt; Dict{InfPlc, Int}
signs(a::FacElem{nf_elem}, l::Vector{InfPlc}) -&gt; Dict{InfPlc, Int}
</code></pre>

<p>This function returns a dictionary of the signs of <script type="math/tex">a</script> at places in <script type="math/tex">l</script>. The keys are the elements of <script type="math/tex">l</script>. The value is <script type="math/tex">1</script> if the sign is positive and <script type="math/tex">-1</script> if the sign is negative. The result will contain as many signs as there are real places contained in <script type="math/tex">l</script>.</p>
<p><a id='Base.sign-Tuple{Union{FacElem{nf_elem,AnticNumberField}, nf_elem},InfPlc}' href='#Base.sign-Tuple{Union{FacElem{nf_elem,AnticNumberField}, nf_elem},InfPlc}'>#</a>
<strong><code>Base.sign</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">sign(a::nf_elem, P::InfPlc)          -&gt; Int
sign(a::FacElem{nf_elem}, P::InfPlc) -&gt; Int
</code></pre>

<p>This function returns the sign of <script type="math/tex">a</script> at the place <script type="math/tex">P</script>. The value is <script type="math/tex">1</script> if the sign is positive and <script type="math/tex">-1</script> if the sign is negative.</p>
<p><a id='Nemo.ispositive-Tuple{Union{FacElem{nf_elem,AnticNumberField}, nf_elem},InfPlc}' href='#Nemo.ispositive-Tuple{Union{FacElem{nf_elem,AnticNumberField}, nf_elem},InfPlc}'>#</a>
<strong><code>Nemo.ispositive</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">ispositive(a::nf_elem, P::InfPlc)          -&gt; Bool
ispositive(a::FacElem{nf_elem}, P::InfPlc) -&gt; Bool
</code></pre>

<p>Returns whether the element <script type="math/tex">a</script> is positive at the embedding corresponding to <script type="math/tex">P</script>. The place <script type="math/tex">P</script> must be real.</p>
<p><a id='Nemo.ispositive-Tuple{Union{FacElem{nf_elem,AnticNumberField}, nf_elem},Array{InfPlc,1}}' href='#Nemo.ispositive-Tuple{Union{FacElem{nf_elem,AnticNumberField}, nf_elem},Array{InfPlc,1}}'>#</a>
<strong><code>Nemo.ispositive</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">ispositive(a::nf_elem, l::Vector{InfPlc})          -&gt; Bool
ispositive(a::FacElem{nf_elem}, l::Vector{InfPlc}) -&gt; Bool
</code></pre>

<p>Returns whether the element <script type="math/tex">a</script> is positive at the embeddings corresponding to the real places of <script type="math/tex">l</script>.</p>
<p><a id='Hecke.istotally_positive-Tuple{Union{FacElem{nf_elem,AnticNumberField}, nf_elem}}' href='#Hecke.istotally_positive-Tuple{Union{FacElem{nf_elem,AnticNumberField}, nf_elem}}'>#</a>
<strong><code>Hecke.istotally_positive</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">istotally_positive(a::nf_elem)          -&gt; Bool
istotally_positive(a::FacElem{nf_elem}) -&gt; Bool
</code></pre>

<p>Returns whether the element <script type="math/tex">a</script> is totally positive, that is, whether it is positive at all places of the ambient number field.</p>
<p><a id='AbstractAlgebra.Generic.valuation-Tuple{FacElem{nf_elem,AnticNumberField},NfAbsOrdIdl{AnticNumberField,nf_elem}}' href='#AbstractAlgebra.Generic.valuation-Tuple{FacElem{nf_elem,AnticNumberField},NfAbsOrdIdl{AnticNumberField,nf_elem}}'>#</a>
<strong><code>AbstractAlgebra.Generic.valuation</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">valuation(a::FacElem{nf_elem, AnticNumberField}, P::NfOrdIdl) -&gt; fmpz
</code></pre>

<p>The valuation of <script type="math/tex">a</script> at <script type="math/tex">P</script>.</p>
<p><a id='AbstractAlgebra.Generic.valuation-Tuple{FacElem{NfAbsOrdIdl{AnticNumberField,nf_elem},Hecke.NfAbsOrdIdlSet{AnticNumberField,nf_elem}},NfAbsOrdIdl{AnticNumberField,nf_elem}}' href='#AbstractAlgebra.Generic.valuation-Tuple{FacElem{NfAbsOrdIdl{AnticNumberField,nf_elem},Hecke.NfAbsOrdIdlSet{AnticNumberField,nf_elem}},NfAbsOrdIdl{AnticNumberField,nf_elem}}'>#</a>
<strong><code>AbstractAlgebra.Generic.valuation</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">valuation(A::FacElem{NfOrdFracIdl, NfOrdFracIdlSet}, p::NfOrdIdl)
valuation(A::FacElem{NfOrdIdl, NfOrdIdlSet}, p::NfOrdIdl)
</code></pre>

<p>The valuation of <script type="math/tex">A</script> at <script type="math/tex">P</script>.</p>
<p><a id='Hecke.evaluate_mod-Tuple{FacElem{nf_elem,AnticNumberField},Hecke.NfOrdFracIdl}' href='#Hecke.evaluate_mod-Tuple{FacElem{nf_elem,AnticNumberField},Hecke.NfOrdFracIdl}'>#</a>
<strong><code>Hecke.evaluate_mod</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">evaluate_mod(a::FacElem{nf_elem, AnticNumberField}, B::NfOrdFracIdl) -&gt; nf_elem
</code></pre>

<p>Evaluates <script type="math/tex">a</script> using CRT and small primes. Assumes that the ideal generated by <script type="math/tex">a</script> is in fact <script type="math/tex">B</script>. Useful in cases where <script type="math/tex">a</script> has huge exponents, but the evaluated element is actually "small".</p>
<p><a id='Hecke.pure_extension-Tuple{Int64,FacElem{nf_elem,AnticNumberField}}' href='#Hecke.pure_extension-Tuple{Int64,FacElem{nf_elem,AnticNumberField}}'>#</a>
<strong><code>Hecke.pure_extension</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">pure_extension(n::Int, gen::FacElem{nf_elem, AnticNumberField}) -&gt; NfRel{nf_elem}, NfRelElem
pure_extension(n::Int, gen::nf_elem) -&gt; NfRel{nf_elem}, NfRelElem
</code></pre>

<p>Create the field extension with the defining polynomial <script type="math/tex">x^n-gen</script>.</p>
<p><a id='Hecke.reduce_ideal2-Tuple{FacElem{NfAbsOrdIdl{AnticNumberField,nf_elem},Hecke.NfAbsOrdIdlSet{AnticNumberField,nf_elem}}}' href='#Hecke.reduce_ideal2-Tuple{FacElem{NfAbsOrdIdl{AnticNumberField,nf_elem},Hecke.NfAbsOrdIdlSet{AnticNumberField,nf_elem}}}'>#</a>
<strong><code>Hecke.reduce_ideal2</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">reduce_ideal2(A::FacElem{NfOrdIdl}) -&gt; NfOrdIdl, FacElem{nf_elem}
</code></pre>

<p>Computes <script type="math/tex">B</script> and <script type="math/tex">\alpha</script> in factored form, such that <script type="math/tex">\alpha B = A</script>.</p>
<p><a id='Hecke.modular_proj-Tuple{FacElem{nf_elem,AnticNumberField},Hecke.modular_env}' href='#Hecke.modular_proj-Tuple{FacElem{nf_elem,AnticNumberField},Hecke.modular_env}'>#</a>
<strong><code>Hecke.modular_proj</code></strong> &mdash; <em>Method</em>.</p>
<p>modular<em>proj(a::FacElem{nf</em>elem, AnticNumberField}, me::modular<em>env) -&gt; Array{fq</em>nmod, 1}</p>
<p>Given an algebraic number <script type="math/tex">a</script> in factored form and data \code{me} as computed by \code{modular_init}, project <script type="math/tex">a</script> onto the residue class fields.</p>
<p><a id='Miscellaneous-1'></a></p>
<h2 id="miscellaneous">Miscellaneous</h2>
<p><a id='Hecke.max_exp-Tuple{FacElem}' href='#Hecke.max_exp-Tuple{FacElem}'>#</a>
<strong><code>Hecke.max_exp</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">max_exp(a::FacElem)
</code></pre>

<p>Finds the largest exponent in the factored element <script type="math/tex">a</script>
</p>
<p><a id='Hecke.min_exp-Tuple{FacElem}' href='#Hecke.min_exp-Tuple{FacElem}'>#</a>
<strong><code>Hecke.min_exp</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">min_exp(a::FacElem)
</code></pre>

<p>Finds the smallest exponent in the factored element <script type="math/tex">a</script>
</p>
<p><a id='Hecke.maxabs_exp-Tuple{FacElem}' href='#Hecke.maxabs_exp-Tuple{FacElem}'>#</a>
<strong><code>Hecke.maxabs_exp</code></strong> &mdash; <em>Method</em>.</p>
<pre><code class="julia">maxabs_exp(a::FacElem)
</code></pre>

<p>Finds the largest exponent by absolute value the factored element <script type="math/tex">a</script>
</p></div>
        
        
    </div>

    <footer class="col-md-12 text-center">
        
        <hr>
        <p>
        <small>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p></small>

        
        
    </footer>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script src="../js/bootstrap-3.0.3.min.js"></script>
    <script src="../js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script>var base_url = ".."</script>
    
    <script src="../js/base.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_HTML"></script>
    <script src="../assets/mathjaxhelper.js"></script>
    <script src="../search/main.js"></script>

    <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form>
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>
    </body>

</html>
